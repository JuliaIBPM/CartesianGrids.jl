<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · CartesianGrids.jl</title><meta name="title" content="Index · CartesianGrids.jl"/><meta property="og:title" content="Index · CartesianGrids.jl"/><meta property="twitter:title" content="Index · CartesianGrids.jl"/><meta name="description" content="Documentation for CartesianGrids.jl."/><meta property="og:description" content="Documentation for CartesianGrids.jl."/><meta property="twitter:description" content="Documentation for CartesianGrids.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CartesianGrids.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../overview/">Overview of staggered grids</a></li><li><a class="tocitem" href="../fielddata/">Setting up field data</a></li><li><a class="tocitem" href="../finitediff/">Mimetic calculus on grid data</a></li><li><a class="tocitem" href="../immersed/">Immersed data and their operations</a></li><li class="is-active"><a class="tocitem" href>Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/CartesianGrids.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/master/docs/src/manual/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.CircularConvolution" href="#CartesianGrids.CircularConvolution"><code>CartesianGrids.CircularConvolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CircularConvolution{M, N, T}</code></pre><p>A preplanned, circular convolution operator on an M × N matrix of data of type T</p><p><strong>Fields</strong></p><ul><li><code>Ĝ</code>: DFT coefficients of the convolution kernel</li><li><code>F</code>: preplanned rFFT operator</li><li><code>F⁻¹</code>: preplanned irFFT operator</li><li><code>nthreads</code> : optimized number of threads to use, if appropriate</li><li><code>paddedSpace</code>: scratch space to zero-pad the input matrix</li><li><code>Â</code>: scratch space to store the DFT coefficients of the zero-padded input matrix</li></ul><p><strong>Constructors:</strong></p><ul><li><code>CircularConvolution(G::Matrix{T})</code></li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; G = repeat(1.0:3,1,4)
3×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 2.0  2.0  2.0  2.0
 3.0  3.0  3.0  3.0

julia&gt; C = CircularConvolution(G)
Circular convolution on a 3 × 4 matrix of data type Float64

julia&gt; C*reshape(1:12, 3, 4)
3×4 Array{Int64,2}:
 164  164  164  164
 130  130  130  130
 148  148  148  148</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/convolution.jl#L3-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.DDF-Tuple{}" href="#CartesianGrids.DDF-Tuple{}"><code>CartesianGrids.DDF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DDF([ddftype=Roma],[dx=1.0])</code></pre><p>Construct a discrete delta function operator. This is generally only needed internally by the <code>Regularize</code> operator, so the user doesn&#39;t have much need for accessing this directly. The default DDF is the <code>Roma</code> function, which has a support of 3 grid cells. Other choices are the <code>Goza</code> operator, which is a truncated Gaussian with 28 cells support, and the <code>Witchhat</code>, which has 2 cells support. The resulting operator is evaluated with one, two or three coordinate arguments, producing, respectively, 1-d, 2-d, or 3-d smeared delta functions. It can also be called with the usual Julia vectorized dot notation with arrays of arguments. The optional cell spacing argument <code>dx</code> rescales the coordinates by this spacing, and the result is also rescaled by this spacing (raised to the number of dimensions). This spacing argument defaults to 1.0.</p><pre><code class="language-julia-repl hljs">julia&gt; ddf = DDF(ddftype=Roma)
Discrete delta function operator of type CartesianGrids.Roma, with spacing 1.0

julia&gt; ddf(1)
0.16666666666666666

julia&gt; ddf(-1)
0.16666666666666666

julia&gt; ddf.([-1,0,1])
3-element Array{Float64,1}:
 0.16666666666666666
 0.6666666666666666
 0.16666666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/ddf.jl#L7-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.EdgeGradient" href="#CartesianGrids.EdgeGradient"><code>CartesianGrids.EdgeGradient</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EdgeGradient</code></pre><p><code>EdgeGradient</code> is a wrapper for tensor-valued data that lie partly at the nodes of dual cells and primary cells. <code>EdgeGradient</code> type data have fields <code>dudx</code>, <code>dudy</code>, <code>dvdx</code>, <code>dvdy</code> for the components of the tensor field. The diagonal components lie at one set of nodes (e.g. Primal), and the offdiagonal at the other set (e.g. Dual).</p><p><strong>Constructors</strong></p><ul><li><code>EdgeGradient(C,dims)</code> creates a tensor field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code>. Note that <code>dims</code> represent the number of dual cells on the grid.</li><li><code>EdgeGradient(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/fields/collections.jl#L115-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.Edges" href="#CartesianGrids.Edges"><code>CartesianGrids.Edges</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Edges</code></pre><p><code>Edges</code> is a wrapper for vector-valued data that lie at the faces of either dual cells or primary cells. <code>Edges</code> type data have fields <code>u</code> and <code>v</code> for the components of the vector field. These are the normal components of the vector field on the vertical and horizontal faces of the corresponding cell.</p><p><strong>Constructors</strong></p><ul><li><code>Edges(C,dims)</code> creates a vector field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code>. Note that <code>dims</code> represent the number of dual cells on the grid.</li><li><code>Edges(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/fields/collections.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.GeneratedField" href="#CartesianGrids.GeneratedField"><code>CartesianGrids.GeneratedField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneratedField(d::GridData,field::AbstractSpatialField...,grid::PhysicalGrid)</code></pre><p>Create an instance of a spatial field function <code>field</code> on scalar grid data <code>d</code>, based on a grid <code>grid</code>. After creating the instance <code>g = GeneratedField(d,field,grid)</code>, then the resulting grid data can be accessed by typing <code>g()</code>. For vector grid data, a separate <code>field</code> must be supplied for each component.</p><p>If the fields are time dependent, then you can also evaluate <code>g(t)</code> at the desired time. The time argument is ignored if the fields are static.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/generatefields.jl#L11-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.InterpolationMatrix" href="#CartesianGrids.InterpolationMatrix"><code>CartesianGrids.InterpolationMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InterpolationMatrix(H::Regularize,u::CellData,f::PointData) -&gt; Emat</code></pre><p>Construct and store a matrix representation of interpolation associated with <code>H</code> for data of type <code>u</code> to data of type <code>f</code>. The resulting matrix <code>Emat</code> can then be used to apply on grid data of type <code>u</code> to interpolate it to point data of type <code>f</code>, using <code>mul!(f,Emat,u)</code>. It can also be used as just <code>Emat*u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/regularization.jl#L214-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.ModulatedField" href="#CartesianGrids.ModulatedField"><code>CartesianGrids.ModulatedField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ModulatedField(g::GeneratedField,modfcn::Abstract1DProfile)</code></pre><p>Create a time-modulated form of a generated spatial field, useful for introducing a forcing field onto the grid. The supplied field <code>g</code> is modulated by a function <code>modfcn</code> with a specified profle shape. The resulting object can be evaluated with a single argument (time) and returns a <code>GridData</code> type object of the same type contained in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/generatefields.jl#L87-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.NodePair" href="#CartesianGrids.NodePair"><code>CartesianGrids.NodePair</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NodePair</code></pre><p><code>NodePair</code> is a wrapper for vector-valued data that lie at the nodes of dual cells and primal cells. <code>NodePair</code> type data have fields <code>u</code> and <code>v</code> for the components of the vector field. These are the normal components of a vector field on nodes that form the faces of a virtual cell centered at one of the faces of the primal cell.</p><p><strong>Constructors</strong></p><ul><li><code>NodePair(C,dims)</code> creates a vector field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code>. Note that <code>dims</code> represent the number of dual cells on the grid.</li><li><code>NodePair(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/fields/collections.jl#L174-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.Nodes" href="#CartesianGrids.Nodes"><code>CartesianGrids.Nodes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Nodes</code></pre><p><code>Nodes</code> is a wrapper for scalar-valued data that lie at the centers of either dual cells or primary cells. A <code>Nodes</code> type can be accessed by indexing like any other array, and allows the use of <code>size</code>, <code>similar</code>, <code>zero</code> functions.</p><p><strong>Constructors</strong></p><ul><li><code>Nodes(C,dims)</code> creates a field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code> (a tuple). Note that <code>dims</code> represent the number of dual cells on the grid, even if <code>C</code> is <code>Primal</code>.</li><li><code>Nodes(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/fields/scalargrid.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.PhysicalGrid-Tuple{Tuple{Real, Real}, Tuple{Real, Real}, Float64}" href="#CartesianGrids.PhysicalGrid-Tuple{Tuple{Real, Real}, Tuple{Real, Real}, Float64}"><code>CartesianGrids.PhysicalGrid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PhysicalGrid(xlim::Tuple{Real,Real},ylim::Tuple{Real,Real},Δx::Float64;[opt_type=:none,optimize_threads=false,nthreads_max=1])</code></pre><p>Constructor to set up a grid connected to physical space. The region to be discretized by the grid is defined by the limits <code>xlim</code> and <code>ylim</code>, and the cell spacing (uniform and indentical in each direction) is specified by <code>Δx</code>. The constructor uses this information to determine the number of cells in each direction, expanding the given range if necessary to accommodate an integer number. It also pads each side with a ghost cell. It also determines the indices corresponding to the corner of the cell to which the physical origin corresponds. Note that the corner corresponding to the lowest limit in each direction has indices (1,1).</p><p>There are a few optional arguments devoted to optimization of the grid size. The <code>nthreads_max</code> sets the number of FFT compute threads to use and  can be set to a value up to the total number available on the architecture. It defaults to 1. </p><p>The keyword <code>opt_type</code> can be set to <code>:threads</code>, <code>:prime</code> (default), or <code>:none</code>. If <code>:none</code>, then the grid is set as close to the specified range as possible. If <code>:prime</code>, then the grid is expanded in each direction to a number that is a product of primes (and therefore efficient in an FFT). If <code>:threads</code>, then the grid is tested with a representative calculation on various grid sizes to identify one that has the minimum cpu time. If <code>optimize_threads = true</code>, then the number of threads is also varied (between 1 and <code>nthreads_max</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L52-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.RegularizationMatrix" href="#CartesianGrids.RegularizationMatrix"><code>CartesianGrids.RegularizationMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RegularizationMatrix(H::Regularize,f::PointData,u::CellData) -&gt; Hmat</code></pre><p>Construct and store a matrix representation of regularization associated with <code>H</code> for data of type <code>f</code> to data of type <code>u</code>. The resulting matrix <code>Hmat</code> can then be used to apply on point data of type <code>f</code> to regularize it to grid data of type <code>u</code>, using <code>mul!(u,Hmat,f)</code>. It can also be used as just <code>Hmat*f</code>.</p><p>If <code>H</code> is a symmetric regularization and interpolation operator, then this actually returns a tuple <code>Hmat, Emat</code>, where <code>Emat</code> is the interpolation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/regularization.jl#L195-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.Regularize-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector{D}, AbstractVector{D}, T}} where {T&lt;:Real, D&lt;:Real}" href="#CartesianGrids.Regularize-Union{Tuple{D}, Tuple{T}, Tuple{AbstractVector{D}, AbstractVector{D}, T}} where {T&lt;:Real, D&lt;:Real}"><code>CartesianGrids.Regularize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Regularize(x,y,dx,[ddftype=Yang3],[graddir=0],[I0=(1,1)], [weights=1.0], [filter=false],
                   [issymmetric=false])</code></pre><p>Constructor to set up an operator for regularizing and interpolating data from/to points immersed in the grid to/from fields on the grid itself. The supplied <code>x</code> and <code>y</code> represent physical coordinates of the immersed points, and <code>dx</code> denotes a uniform physical cell size of the grid. The separate arguments <code>x</code> and <code>y</code> can be replaced by a single argument <code>X</code> of type <code>VectorData</code> holding the coordinates.</p><p>The operations of regularization and interpolation are carried out with a discrete delta function (ddf), which defaults to the type <code>Yang3</code>. Others are also possible, such as <code>Roma</code>, <code>Goza</code> or <code>M3</code>. The optional argument <code>graddir</code>, if set to 1 or 2, will generate an interpolation operator that evaluates the negative of the respective component of the gradient of a grid field at the immersed points. The default value of this argument is 0, which simply interpolates. Note that the regularization form of this gradient type is also possible.</p><p>The optional tuple <code>I0</code> represents the indices of the primary node that coincides with <code>(x,y) = (0,0)</code>. This defaults to <code>(1,1)</code>, which leaves one layer of ghost (dual) cells and sets the physical origin in the lower left corner of the grid of interior dual cells.</p><p>Another optional parameter, <code>weights</code>, sets the weight of each point in the regularization. This would generally be set with, say, the differential arc length for regularization of data on a curve. It can be a vector (of the same length as x and y) or a scalar if uniform. It defaults to 1.0.</p><p>The optional Boolean parameter <code>filter</code> can be set to <code>true</code> if it is desired to apply filtering (see Goza et al, J Comput Phys 2016) to the grid data before interpolating. This is generally only used in the context of preconditioning the solution for forces on the immersed points.</p><p>If the optional Boolean parameter <code>issymmetric</code> is set to <code>true</code>, then the regularization and interpolation are constructed to be transposes of each other. Note that this option overrides any supplied weights. The default of this parameter is <code>false</code>.</p><p>The resulting operator can be used in either direction, regularization and interpolation, with the first argument representing the <em>target</em> (the entity to regularize/interpolate to), and the second argument the <em>source</em> (the entity to regularize/interpolate from). The regularization does not use the filtering option.</p><p><strong>Example</strong></p><p>In the example below, we set up a 12 x 12 grid. Using the default value for <code>I0</code> and setting <code>dx = 0.1</code>, the physical dimensions of the non-ghost part of the grid are 1.0 x 1.0. Three points are set up in the interior, and a vector field is assigned to them, with the x component of each of them set to 1.0. These data are regularized to a field of primal edges on the grid, using the Roma DDF kernel.</p><pre><code class="language-julia-repl hljs">julia&gt; x = [0.25,0.75,0.25]; y = [0.75,0.25,0.25];

julia&gt; X = VectorData(x,y);

julia&gt; q = Edges(Primal,(12,12));

julia&gt; dx = 0.1;

julia&gt; H = Regularize(x,y,dx;ddftype=Roma)
Regularization/interpolation operator with non-filtered interpolation
  DDF type CartesianGrids.Roma
  3 points in grid with cell area 0.01

julia&gt; f = VectorData(X);

julia&gt; fill!(f.u,1.0);

julia&gt; H(q,f)
Edges{Primal,12,12,Float64} data
u (in grid orientation)
11×12 Array{Float64,2}:
 0.0  0.0  0.0       0.0     0.0      …  0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     0.0       0.0     0.0      0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0      …  0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     8.33333  33.3333  8.33333  0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     8.33333  33.3333  8.33333  0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0      …  0.0       0.0     0.0      0.0  0.0
v (in grid orientation)
12×11 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/regularization.jl#L27-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.ScalarData" href="#CartesianGrids.ScalarData"><code>CartesianGrids.ScalarData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScalarData &lt;: PointData</code></pre><p>A wrapper for a one-dimensional array of scalar-valued data. The resulting wrapper can be indexed in the same way as the array itself.</p><p><strong>Constructors</strong></p><ul><li><code>ScalarData(d::AbstractVector[,dtype=Float64])</code> constructs a wrapper for the one-dimensional array of data <code>d</code></li><li><code>ScalarData(n::Int)</code> constructs a wrapper for an array of zeros of length <code>n</code>.</li><li><code>ScalarData(x::PointData)</code> constructs a wrapper for an array of zeros of the  same length as that wrapped by <code>x</code>.</li><li><code>ScalarData(n::Int,dtype=ComplexF64)</code> constructs a wrapper for complex-valued data.</li><li><code>ScalarData(x::PointData,dtype=ComplexF64)</code> constructs a wrapper for an array of  complex zeros of the same length as that wrapped by <code>x</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = ScalarData(10);

julia&gt; f[5] = 1.0;

julia&gt; f
10 points of scalar-valued Float64 data
10-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/points.jl#L6-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.TensorData" href="#CartesianGrids.TensorData"><code>CartesianGrids.TensorData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TensorData &lt;: PointData</code></pre><p>A wrapper for a one-dimensional array of 2x2 tensor-valued data, with fields <code>dudx</code>, <code>dudy</code>, <code>dvdx</code>, <code>dvdy</code>. The resulting wrapper can be indexed as though these four components are stacked on top of each other.</p><p><strong>Constructors</strong></p><ul><li><code>TensorData(d::AbstractVector[,dtype=Float64])</code> constructs a wrapper for the one-dimensional array of data <code>d</code>, splitting <code>d</code> into the four components evenly.</li><li><code>TensorData(dudx,dudy,dvdx,dvdy)</code> constructs a wrapper for the tensor components data, each of type <code>AbstractVector</code></li><li><code>TensorData(n::Int)</code> constructs a wrapper with zeros of length <code>n</code> for all components.</li><li><code>TensorData(x::PointData[,dtype=Float64])</code> constructs a wrapper for zero components of the  same length as that wrapped by <code>x</code>.</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/points.jl#L147-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.VectorData" href="#CartesianGrids.VectorData"><code>CartesianGrids.VectorData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorData &lt;: PointData</code></pre><p>A wrapper for a one-dimensional array of two-component vector-valued data. The resulting wrapper can be indexed as though the first component and second component are stacked on top of each other.</p><p><strong>Constructors</strong></p><ul><li><code>VectorData(d::AbstractVector[,dtype=Float64])</code> constructs a wrapper for the one-dimensional array of data <code>d</code>, splitting <code>d</code> into the <code>u</code> and <code>v</code> components evenly.</li><li><code>VectorData(u::AbstractVector,v::AbstractVector)</code> constructs a wrapper for the vector components data <code>u</code> and <code>v</code>.</li><li><code>VectorData(n::Int)</code> constructs a wrapper with zeros of length <code>n</code> for both components.</li><li><code>VectorData(x::PointData)</code> constructs a wrapper for zero components of the  same length as that wrapped by <code>x</code>.</li><li><code>VectorData(n::Int,dtype=ComplexF64)</code> constructs a wrapper with complex-valued zeros  of length <code>n</code> for both components.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = VectorData(10,dtype=ComplexF64);

julia&gt; f.v[1:5] = 1:5;

julia&gt; f
10 points of vector-valued Complex{Float64} data
10×2 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im
 0.0+0.0im  2.0+0.0im
 0.0+0.0im  3.0+0.0im
 0.0+0.0im  4.0+0.0im
 0.0+0.0im  5.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im

julia&gt; f[7] = 1im; f[18] = 0.2;

julia&gt; f
10 points of vector-valued Complex{Float64} data
10×2 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im
 0.0+0.0im  2.0+0.0im
 0.0+0.0im  3.0+0.0im
 0.0+0.0im  4.0+0.0im
 0.0+0.0im  5.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+1.0im  0.0+0.0im
 0.0+0.0im  0.2+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/points.jl#L59-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.XEdges" href="#CartesianGrids.XEdges"><code>CartesianGrids.XEdges</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">XEdges</code></pre><p><code>XEdges</code> is a wrapper for scalar-valued data that lie at the centers of either dual cells or primary cells. A <code>XEdges</code> type can be accessed by indexing like any other array, and allows the use of <code>size</code>, <code>similar</code>, <code>zero</code> functions.</p><p><strong>Constructors</strong></p><ul><li><code>XEdges(C,dims)</code> creates a field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code> (a tuple). Note that <code>dims</code> represent the number of dual cells on the grid, even if <code>C</code> is <code>Primal</code>.</li><li><code>XEdges(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/fields/scalargrid.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.YEdges" href="#CartesianGrids.YEdges"><code>CartesianGrids.YEdges</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">YEdges</code></pre><p><code>YEdges</code> is a wrapper for scalar-valued data that lie at the centers of either dual cells or primary cells. A <code>YEdges</code> type can be accessed by indexing like any other array, and allows the use of <code>size</code>, <code>similar</code>, <code>zero</code> functions.</p><p><strong>Constructors</strong></p><ul><li><code>YEdges(C,dims)</code> creates a field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code> (a tuple). Note that <code>dims</code> represent the number of dual cells on the grid, even if <code>C</code> is <code>Primal</code>.</li><li><code>YEdges(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/fields/scalargrid.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}}} where N" href="#Base.:*-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}}} where N"><code>Base.:*</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(*)(p::VectorData,q::VectorData) -&gt; TensorData</code></pre><p>Calculate the element by element tensor product between vectors <code>p</code> and <code>q</code>, returning <code>TensorData</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L298-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{VectorData, Tuple{T, T}}} where T&lt;:Number" href="#Base.:+-Union{Tuple{T}, Tuple{VectorData, Tuple{T, T}}} where T&lt;:Number"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(+)(X::VectorData,a::Tuple{T,T}) where {T&lt;:Number} -&gt; VectorData
(-)(X::VectorData,a::Tuple{T,T}) where {T&lt;:Number} -&gt; VectorData</code></pre><p>Adds or subtracts the tuple <code>a</code> component by component to each element of <code>X</code>. All data in <code>a</code> are converted to Float64. Can also switch the arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = VectorData(5);

julia&gt; f + (2,3)
5 points of vector-valued Float64 data
5×2 Array{Float64,2}:
 2.0  3.0
 2.0  3.0
 2.0  3.0
 2.0  3.0
 2.0  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L460-L481">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Threads.nthreads-Tuple{PhysicalGrid}" href="#Base.Threads.nthreads-Tuple{PhysicalGrid}"><code>Base.Threads.nthreads</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nthreads(g::PhysicalGrid) -&gt; Int</code></pre><p>Return the maximum number of threads allowed for grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Union{Tuple{CartesianGrids.Laplacian{NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY}, Any}} where {NX, NY}" href="#Base.exp-Union{Tuple{CartesianGrids.Laplacian{NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY}, Any}} where {NX, NY}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(L::Laplacian[,Nodes(Dual)][;nthreads=L.conv.nthreads])</code></pre><p>Create the integrating factor exp(L). The default size of the operator is the one appropriate for dual nodes; another size can be specified by supplying grid data in the optional third argument. Note that, if <code>L</code> contains a factor, e.g., by multiplying a <code>Laplacian</code> by a scalar, it scales the exponent with this factor. The number of threads used by the resulting operator can be set by the <code>nthreads</code> optional argument; by default, it takes this number from <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/intfact.jl#L116-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{PhysicalGrid}" href="#Base.length-Tuple{PhysicalGrid}"><code>Base.length</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">length(g::PhysicalGrid,d::Int) -&gt; Int</code></pre><p>Return the total number of cells in grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{PhysicalGrid, Int64}" href="#Base.size-Tuple{PhysicalGrid, Int64}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(g::PhysicalGrid,d::Int) -&gt; Int</code></pre><p>Return the number of cells in direction <code>d</code> in grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{PhysicalGrid}" href="#Base.size-Tuple{PhysicalGrid}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size(g::PhysicalGrid) -&gt; Tuple</code></pre><p>Return a tuple of the number of cells in all directions in grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.transpose-Tuple{TensorData}" href="#Base.transpose-Tuple{TensorData}"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose(p::TensorData) -&gt; TensorData</code></pre><p>Element-by-element transpose of <code>TensorData</code> <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L320-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.transpose-Union{Tuple{EdgeGradient{C, D, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#Base.transpose-Union{Tuple{EdgeGradient{C, D, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose(p::EdgeGradient) -&gt; EdgeGradient</code></pre><p>Element-by-element transpose of <code>EdgeGradient</code> <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/basicoperations.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.zero-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GridData" href="#Base.zero-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:GridData"><code>Base.zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero(p::GridData)</code></pre><p>Return data of the same type as <code>p</code>, filled with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/basicoperations.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.zero-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PointData" href="#Base.zero-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:PointData"><code>Base.zero</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero(p::PointData)</code></pre><p>Return data of the same type as <code>p</code>, filled with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.cellsize-Tuple{PhysicalGrid}" href="#CartesianGrids.cellsize-Tuple{PhysicalGrid}"><code>CartesianGrids.cellsize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cellsize(g::PhysicalGrid) -&gt; Float64</code></pre><p>Return the grid cell size of grid <code>g</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L302-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.convective_derivative!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.convective_derivative!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.convective_derivative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convective_derivative!(out,q)</code></pre><p>Compute the convective derivative of <code>q</code> in the form <span>$u\cdot\nabla u$</span> and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.convective_derivative_rot!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.convective_derivative_rot!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.convective_derivative_rot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convective_derivative_rot!(out,q)</code></pre><p>Compute the rotational form of the convective derivative of <code>q</code> in the form <span>$\frac{1}{2}\nabla|u|^2-u\times(\nabla\times u)$</span> and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L187-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.coordinates" href="#CartesianGrids.coordinates"><code>CartesianGrids.coordinates</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordinates(w::GridData;[dx=1.0],[I0=(1,1)])</code></pre><p>Return a tuple of the ranges of the physical coordinates in each direction for grid data <code>w</code>. If <code>w</code> is of <code>Nodes</code> type, then it returns a tuple of the form <code>xg,yg</code>. If <code>w</code> is of <code>Edges</code> or <code>NodePair</code> type, then it returns a tuple of the form <code>xgu,ygu,xgv,ygv</code>.</p><p>The optional keyword argument <code>dx</code> sets the grid spacing; its default is <code>1.0</code>. The optional keyword <code>I0</code> accepts a tuple of integers to set the index pair of the primal nodes that coincide with the origin. The default is <code>(1,1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Dual,(12,22));

julia&gt; xg, yg = coordinates(w,dx=0.1)
(-0.05:0.1:1.05, -0.05:0.1:2.0500000000000003)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.coordinates-Tuple{Any, PhysicalGrid}" href="#CartesianGrids.coordinates-Tuple{Any, PhysicalGrid}"><code>CartesianGrids.coordinates</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordinates(w::Nodes/Edges,g::PhysicalGrid) -&gt; Range</code></pre><p>Return coordinate data range for type of <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.curl!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.curl!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.curl!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">curl!(q::Edges{Primal},w::Nodes{Dual})</code></pre><p>Evaluate the discrete curl of <code>w</code> and return it as <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Dual,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; q = Edges(Primal,w);

julia&gt; curl!(q,w)
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  -1.0  1.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.curl-Union{Tuple{Nodes{Dual, NX, NY, T}}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}" href="#CartesianGrids.curl-Union{Tuple{Nodes{Dual, NX, NY, T}}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}"><code>CartesianGrids.curl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">curl(w::Nodes{Dual}) --&gt; Edges{Primal}</code></pre><p>Evaluate the discrete curl of <code>w</code>. Another way to perform this operation is to construct a <code>Curl</code> object and apply it with <code>*</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; C = Curl();

julia&gt; w = Nodes(Dual,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; C*w
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  -1.0  1.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L51-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.curl_cross!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.curl_cross!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.curl_cross!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">curl_cross!(out,a,b)</code></pre><p>Compute the curl of the cross product of <code>a</code> and <code>b</code>, <span>$\nabla\times(a\times b)$</span>, and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.diff!" href="#CartesianGrids.diff!"><code>CartesianGrids.diff!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diff!(out:ScalarGridData,in::ScalarGridData) -&gt; ScalarGridData</code></pre><p>Return the 1-d central finite difference of scalar grid data <code>in</code> in scalar grid data <code>out</code>. Either <code>in</code> or <code>out</code> must be edge component data and the other must be node data. The direction of differencing is determined by the relationship of <code>in</code> and <code>out</code>. For example, if <code>in</code> is dual nodes (cell by cell) and <code>out</code> is primal x-edge components (cell by edge), then the differencing takes place in the y direction, since they are different types in this direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/differencing1d.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.directional_derivative!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.directional_derivative!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.directional_derivative!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">directional_derivative!(out,f,q)</code></pre><p>Compute the directional derivative of <code>f</code> in the direction of <code>q</code>, <span>$q\cdot\nabla f$</span>, and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.directional_derivative_conserve!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.directional_derivative_conserve!-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.directional_derivative_conserve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">directional_derivative_conserve!(out,f,q)</code></pre><p>Compute the conservative form of the directional derivative of <code>f</code> in the direction of <code>q</code>, <span>$\nabla\cdot(qf)$</span>, and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing. This form is only appropriate if <code>q</code> is divergence free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, EdgeGradient{Primal, Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, EdgeGradient{Primal, Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.divergence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divergence!(w::Edges,q::EdgeGradient)</code></pre><p>Evaluate the discrete divergence of edge gradient tensor data <code>q</code> and return it as data <code>w</code>. Note that <code>q</code> can be either primal/dual or dual/primal tensor data, and <code>w</code> must be, respectively, primal or edges type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L222-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY}, Edges{Primal, NX, NY}}} where {NX, NY}" href="#CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY}, Edges{Primal, NX, NY}}} where {NX, NY}"><code>CartesianGrids.divergence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divergence!(w::Nodes,q::Edges)</code></pre><p>Evaluate the discrete divergence of edge data <code>q</code> and return it as nodal data <code>w</code>. Note that <code>q</code> can be either primal or dual edge data, but <code>w</code> must be of the same cell type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[3,2] = 1.0;

julia&gt; w = Nodes(Primal,(8,6));

julia&gt; divergence!(w,q)
Nodes{Primal,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
5×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L107-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Union{XEdges{Primal, NX, NY}, YEdges{Dual, NX, NY}}, NodePair{Primal, Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Union{XEdges{Primal, NX, NY}, YEdges{Dual, NX, NY}}, NodePair{Primal, Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.divergence!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divergence!(w::XEdges/YEdges,q::NodePair)</code></pre><p>Evaluate the discrete divergence of node pair data <code>q</code> and return it as data <code>w</code>. Note that <code>q</code> can be either primal/dual or dual/primal node data, and <code>w</code> must be, respectively, primal x-edges/dual y-edges or primal y-edges/dual x-edges type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.divergence-Union{Tuple{EdgeGradient{T, S, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{S}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, S&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.divergence-Union{Tuple{EdgeGradient{T, S, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{S}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, S&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.divergence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divergence(dq::EdgeGradient) --&gt; Edges</code></pre><p>Evaluate the discrete divergence of edge gradient data <code>dq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.divergence-Union{Tuple{Edges{T, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.divergence-Union{Tuple{Edges{T, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.divergence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divergence(q::Edges) --&gt; Nodes</code></pre><p>Evaluate the discrete divergence of edge data <code>q</code>. Can also perform this operation by creating an object of Divergence type and applying it with <code>*</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Divergence();

julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[3,2] = 1.0;

julia&gt; D*q
Nodes{Primal,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
5×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L159-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.exp!-Union{Tuple{CartesianGrids.Laplacian{NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY}, Any}} where {NX, NY}" href="#CartesianGrids.exp!-Union{Tuple{CartesianGrids.Laplacian{NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY}, Any}} where {NX, NY}"><code>CartesianGrids.exp!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp!(L::Laplacian[,Nodes(Dual)][;nthreads=L.conv.nthreads])</code></pre><p>Create the in-place version of the integrating factor exp(L).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/intfact.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Dual, Primal, NX, NY}, Edges{Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Dual, Primal, NX, NY}, Edges{Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad!(d::EdgeGradient{Dual,Primal},q::Edges{Dual})</code></pre><p>Evaluate the discrete gradient of dual edge data <code>q</code> and return it as edge gradient data <code>d</code>, where the diagonal entries of the gradient lie on dual nodes and the off-diagonal entries lie at primal nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L416-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY}, Edges{Primal, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY}, Edges{Primal, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad!(d::EdgeGradient{Primal,Dual},q::Edges{Primal})</code></pre><p>Evaluate the discrete gradient of primal edge data <code>q</code> and return it as edge gradient data <code>d</code>, where the diagonal entries of the gradient lie on primal nodes and the off-diagonal entries lie at dual nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L391-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad!(q::Edges{Dual},w::Nodes{Dual})</code></pre><p>Evaluate the discrete gradient of dual nodal data <code>w</code> and return it as dual edge data <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L361-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, Nodes{Primal, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, Nodes{Primal, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad!(q::Edges{Primal},w::Nodes{Primal})</code></pre><p>Evaluate the discrete gradient of primal nodal data <code>w</code> and return it as primal edge data <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Primal,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; q = Edges(Primal,(8,6));

julia&gt; grad!(q,w)
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L275-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grad-Union{Tuple{Edges{C, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.grad-Union{Tuple{Edges{C, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad(q::Edges{Primal/Dual}) --&gt; EdgeGradient{Dual/Primal,Primal/Dual}</code></pre><p>Evaluate the discrete gradient of primal or dual edge data <code>q</code>. Can also perform this operation by creating an object of Grad type and applying it with <code>*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L441-L446">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grad-Union{Tuple{Nodes{Dual, NX, NY}}, Tuple{NY}, Tuple{NX}} where {NX, NY}" href="#CartesianGrids.grad-Union{Tuple{Nodes{Dual, NX, NY}}, Tuple{NY}, Tuple{NX}} where {NX, NY}"><code>CartesianGrids.grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad(w::Nodes{Dual}) --&gt; Edges{Dual}</code></pre><p>Evaluate the discrete gradient of dual nodal data <code>w</code>. Can also perform this operation by creating an object of Grad type and applying it with <code>*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L381-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grad-Union{Tuple{Nodes{Primal, NX, NY, T}}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}" href="#CartesianGrids.grad-Union{Tuple{Nodes{Primal, NX, NY, T}}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}"><code>CartesianGrids.grad</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grad(w::Nodes{Primal}) --&gt; Edges{Primal}</code></pre><p>Evaluate the discrete gradient of primal nodal data <code>w</code>. Can also perform this operation by creating an object of Grad type and applying it with <code>*</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Primal,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; G = Grad();

julia&gt; G*w
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/diffcalculus.jl#L323-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grid_interpolate!" href="#CartesianGrids.grid_interpolate!"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolate!(out:ScalarGridData,in::ScalarGridData) -&gt; ScalarGridData</code></pre><p>Return the 1-d symmetric interpolation of scalar grid data <code>in</code> onto scalar grid data <code>out</code>. Either <code>in</code> or <code>out</code> must be edge component data and the other must be node data. The direction of interpolation is determined by the relationship of <code>in</code> and <code>out</code>. For example, if <code>in</code> is dual nodes (cell by cell) and <code>out</code> is primal x-edge components (cell by edge), then the interpolation takes place in the y direction, since they are different types in this direction. (In the x direction, they are of the same type (cell), so there is no interpolation in that direction.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/interpolation1d.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{Tuple{Nodes{C, NX, NY}, Nodes{C, NX, NY}}, Edges{D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{Tuple{Nodes{C, NX, NY}, Nodes{C, NX, NY}}, Edges{D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolate!((wx::Nodes,wy::Nodes),q::Edges)</code></pre><p>Interpolate the edge data <code>q</code> (of either dual or primal type) to the dual or primal nodes, and return the result in <code>wx</code> and <code>wy</code>. <code>wx</code> holds the shifted <code>q.u</code> data and <code>wy</code> the shifted <code>q.v</code> data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[3,2] = 1.0;

julia&gt; wx = Nodes(Dual,(8,6)); wy = deepcopy(wx);

julia&gt; grid_interpolate!((wx,wy),q);

julia&gt; wx
Nodes{Dual,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0

julia&gt; wy
Nodes{Dual,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/shift.jl#L59-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY}, Edges{Primal, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY}, Edges{Primal, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolate!(dq::EdgeGradient{Primal/Dual},q::Edges{Primal/Dual})</code></pre><p>Interpolate the primal (dual) edge data <code>q</code> to primal (dual) tensor positions and hold it in <code>dq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/shift.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolate!(q::Edges{Dual},w::Nodes{Dual})</code></pre><p>Interpolate the dual nodal data <code>w</code> to the edges of the dual cells, and return the result in <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Dual,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; q = Edges(Dual,w);

julia&gt; grid_interpolate!(q,w)
Edges{Dual,8,6,Float64} data
u (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.5  0.5  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/shift.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, EdgeGradient{Primal, Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, EdgeGradient{Primal, Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolate!(q::Edges{Primal/Dual},dq::EdgeGradient{Primal/Dual})</code></pre><p>Interpolate the primal (dual) tensor data <code>dq</code> to primal (dual) edge positions and hold it in <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/shift.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, Nodes{Primal, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY}, Nodes{Primal, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolate!(q::Edges{Primal},w::Nodes{Primal})</code></pre><p>Interpolate the primal nodal data <code>w</code> to the edges of the primal cells, and return the result in <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/shift.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolate!(v::Nodes{Dual/Primal},q::Nodes{Primal/Dual})</code></pre><p>Interpolate the primal (resp. dual) node data <code>q</code> to the edges of the dual (resp. primal) nodes, and return the result in <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/shift.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.gridwise_dot!-Union{Tuple{C}, Tuple{Nodes{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.gridwise_dot!-Union{Tuple{C}, Tuple{Nodes{C}, Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.gridwise_dot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>gridwise_dot!(udotv::Nodes{Primal/Dual},u::Edges{Primal/Dual},v::Edges{Primal/Dual})</p><p>Calculate the in-placed dot product of vector grid data <code>u</code> and <code>v</code>, placing the result on the cell centers or nodes in <code>udotv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.gridwise_dot-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.gridwise_dot-Union{Tuple{C}, Tuple{Edges{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.gridwise_dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>gridwise_dot(u::Edges{Primal/Dual},v::Edges{Primal/Dual})</p><p>Calculate the dot product of vector grid data <code>u</code> and <code>v</code>, placing the result on the cell centers (if data are Edges{Primal}) or nodes (if data are Edges{Dual}).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.helmholtz!-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T}, Nodes{Dual, NX, NY, T}, Number}} where {NX, NY, T&lt;:ComplexF64}" href="#CartesianGrids.helmholtz!-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T}, Nodes{Dual, NX, NY, T}, Number}} where {NX, NY, T&lt;:ComplexF64}"><code>CartesianGrids.helmholtz!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">helmholtz!(v,w,α)</code></pre><p>Evaluate the discrete Helmholtz operator (iα - L) on <code>w</code> and return it as <code>v</code>. The data <code>w</code> can be of type dual/primary nodes or edges; <code>v</code> must be of the same type. However, both have to be of complex data type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/helmholtz.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.helmholtz-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Nodes{C, NX, NY, T}, Number}} where {C&lt;:CartesianGrids.CellType, NX, NY, T&lt;:ComplexF64}" href="#CartesianGrids.helmholtz-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Nodes{C, NX, NY, T}, Number}} where {C&lt;:CartesianGrids.CellType, NX, NY, T&lt;:ComplexF64}"><code>CartesianGrids.helmholtz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">helmholtz(w,α)</code></pre><p>Evaluate the discrete Helmholtz operator (iα - L) on <code>w</code>. The data <code>w</code> can be of complex type dual/primary nodes or edges. The returned result is of the same type as <code>w</code>.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/helmholtz.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.integrate-Tuple{T} where T&lt;:GridData" href="#CartesianGrids.integrate-Tuple{T} where T&lt;:GridData"><code>CartesianGrids.integrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(p::GridData) -&gt; Real</code></pre><p>Computes a numerical quadrature of node data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.interpolatable_field-Tuple{AbstractArray, AbstractArray, ScalarGridData}" href="#CartesianGrids.interpolatable_field-Tuple{AbstractArray, AbstractArray, ScalarGridData}"><code>CartesianGrids.interpolatable_field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolatable_field(x,y,f::ScalarGridData)</code></pre><p>Generates an interpolatable version of grid data <code>f</code>, based on coordinates in <code>x</code> and <code>y</code> (which should be in range form). The output can be called as a function with coordinate pairs as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/interpolation.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.interpolatable_field-Tuple{AbstractRange, AbstractRange, AbstractRange, AbstractRange, Union{Edges, NodePair}}" href="#CartesianGrids.interpolatable_field-Tuple{AbstractRange, AbstractRange, AbstractRange, AbstractRange, Union{Edges, NodePair}}"><code>CartesianGrids.interpolatable_field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolatable_field(xu,yu,xv,yv,f::EdgeData/NodePair)</code></pre><p>Generates an interpolatable version of grid data <code>f</code>, based on coordinates in <code>xu</code>, <code>yu</code>, <code>xv</code>, <code>yv</code> (which should be in range form). The output can be called as a function with coordinate pairs as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/interpolation.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.interpolatable_field-Tuple{GridData, PhysicalGrid}" href="#CartesianGrids.interpolatable_field-Tuple{GridData, PhysicalGrid}"><code>CartesianGrids.interpolatable_field</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolatable_field(f::GridData,g::PhysicalGrid)</code></pre><p>Generates an interpolatable version of grid data <code>f</code>, based on grid <code>g</code>. The output can be called as a function with coordinate pairs as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/interpolation.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.laplacian!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.laplacian!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.laplacian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laplacian!(v,w)</code></pre><p>Evaluate the discrete Laplacian of <code>w</code> and return it as <code>v</code>. The data <code>w</code> can be of type dual/primary nodes or edge components or edges; <code>v</code> must be of the same type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Dual,(8,6));

julia&gt; v = deepcopy(w);

julia&gt; w[4,3] = 1.0;

julia&gt; laplacian!(v,w)
Nodes{Dual,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×8 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  -4.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/laplacian.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.laplacian-Union{Tuple{Nodes{C, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.laplacian-Union{Tuple{Nodes{C, NX, NY}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.laplacian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laplacian(w)</code></pre><p>Evaluate the discrete Laplacian of <code>w</code>. The data <code>w</code> can be of type dual/primary nodes or edges. The returned result is of the same type as <code>w</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[2,2] = 1.0;

julia&gt; laplacian(q)
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0   0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0   1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  -4.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/laplacian.jl#L131-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.laplacian_symm!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}" href="#CartesianGrids.laplacian_symm!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}"><code>CartesianGrids.laplacian_symm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laplacian_symm!(v,w)</code></pre><p>Evaluate the symmetric 5-point discrete Laplacian of <code>w</code> and return it as <code>v</code>. The data <code>w</code> can be of type dual nodes only for now. This symmetric Laplacian also evaluates the partial Laplacians (using only available stencil data) on the ghost nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/laplacian.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.limits-Tuple{PhysicalGrid, Int64}" href="#CartesianGrids.limits-Tuple{PhysicalGrid, Int64}"><code>CartesianGrids.limits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">limits(g::PhysicalGrid,d::Int) -&gt; Tuple</code></pre><p>Return the minimum and maximum physical dimensions in direction <code>d</code> for grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.mag!-Union{Tuple{C}, Tuple{Nodes{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.mag!-Union{Tuple{C}, Tuple{Nodes{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.mag!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mag!(magu::Nodes{Primal/Dual},u::Edges{Primal/Dual})</code></pre><p>Calculate the in-placed magnitude of vector grid data <code>u</code>, placing the result on the cell centers in <code>magu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.mag-Union{Tuple{Edges{C}}, Tuple{C}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.mag-Union{Tuple{Edges{C}}, Tuple{C}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.mag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>mag(u::Edges{Primal/Dual}) -&gt; Nodes{Primal/Dual}</p><p>Calculate the magnitude of vector grid data <code>u</code>, placing the result on the cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.magsq!-Union{Tuple{C}, Tuple{Nodes{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.magsq!-Union{Tuple{C}, Tuple{Nodes{C}, Edges{C}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.magsq!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>magsq!(magusq::Nodes{Primal/Dual},u::Edges{Primal/Dual})</p><p>Calculate the in-placed squared magnitude of vector grid data <code>u</code>, placing the result on the cell centers in <code>magusq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.magsq-Union{Tuple{Edges{C}}, Tuple{C}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.magsq-Union{Tuple{Edges{C}}, Tuple{C}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.magsq</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>magsq(u::Edges{Primal/Dual}) -&gt; Nodes{Primal/Dual}</p><p>Calculate the squared magnitude of vector grid data <code>u</code>, placing the result on the cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/nlcalculus.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.optimize_gridsize-Tuple{Any, Any}" href="#CartesianGrids.optimize_gridsize-Tuple{Any, Any}"><code>CartesianGrids.optimize_gridsize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_gridsize(nx0,ny0[;region_size=4,optimize_threads=true,nthreads_max=length(cpu_info()),nsamp=1])</code></pre><p>Given a nominal grid size (<code>nx0</code> x <code>ny0</code>), determine the optimal grid size that minimizes the compute time. Optional arguments are the <code>optimize_threads</code> flag and the maximum number of threads <code>nthreads_max</code> (if multithreading is allowed) and the number of samples to take of the cpu time for each trial. Returns optimal <code>nx</code>, <code>ny</code>, and the corresponding CPU time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.origin-Tuple{PhysicalGrid}" href="#CartesianGrids.origin-Tuple{PhysicalGrid}"><code>CartesianGrids.origin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">origin(g::PhysicalGrid) -&gt; Tuple{Int,Int}</code></pre><p>Return a tuple of the indices of the primal node that corresponds to the physical origin of the coordinate system used by <code>g</code>. Note that these indices need not lie inside the range of indices occupied by the grid. For example, if the range of physical coordinates occupied by the grid is (1.0,3.0) x (2.0,4.0), then the origin is not inside the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L291-L299">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_helmholtz" href="#CartesianGrids.plan_helmholtz"><code>CartesianGrids.plan_helmholtz</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_helmholtz(dims::Tuple,α::Number,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [factor=1.0],[dx=1.0])</code></pre><p>Constructor to set up an operator for evaluating the discrete Helmholtz operator on complex dual or primal nodal data of dimension <code>dims</code>. If the optional keyword <code>with_inverse</code> is set to <code>true</code>, then it also sets up the inverse Helmholtz operator (the lattice Green&#39;s function, LGF). These can then be applied, respectively, with <code>*</code> and <code>\</code> operations on data of the appropriate size. The optional parameter <code>factor</code> is a scalar used to multiply the result of the operator and divide the inverse. The optional parameter <code>dx</code> is used in adjusting the uniform value of the LGF to match the behavior of the continuous analog at large distances; this is set to 1.0 by default.</p><p>Instead of the first argument, one can also supply <code>w::Nodes</code> to specify the size of the domain.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/helmholtz.jl#L60-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_helmholtz!" href="#CartesianGrids.plan_helmholtz!"><code>CartesianGrids.plan_helmholtz!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_helmholtz!(dims::Tuple,α::Number,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [factor=1.0],[dx=1.0])</code></pre><p>Same as <a href="#CartesianGrids.plan_helmholtz"><code>plan_helmholtz</code></a>, but forms an operator that works in-place on the data it operates on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/helmholtz.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_implicit_diffusion" href="#CartesianGrids.plan_implicit_diffusion"><code>CartesianGrids.plan_implicit_diffusion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_implicit_diffusion(a::Real,dims::Tuple,[fftw_flags=FFTW.ESTIMATE])</code></pre><p>Constructor to set up the forward and inverse operators of <code>I - a*L</code> where <code>L</code> is the discrete Laplacian (not scaled by grid spacing) and <code>a</code> is a real-valued parameter. This can then be applied with the <code>*</code> or `` operation on data of the appropriate size.</p><p>The <code>dims</code> argument can be replaced with data of type <code>ScalarGridData</code> to specify the size of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/implicitdiffusion.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_implicit_diffusion!" href="#CartesianGrids.plan_implicit_diffusion!"><code>CartesianGrids.plan_implicit_diffusion!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_implicit_diffusion!(a::Real,dims::Tuple,[fftw_flags=FFTW.ESTIMATE][,nthreads=length(Sys.cpu_info())])</code></pre><p>Same as <a href="#CartesianGrids.plan_implicit_diffusion"><code>plan_implicit_diffusion</code></a>, but the resulting operator performs an in-place operation on data. The number of threads <code>threads</code> defaults to the number of logical CPU cores on the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/implicitdiffusion.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_intfact" href="#CartesianGrids.plan_intfact"><code>CartesianGrids.plan_intfact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_intfact(a::Real,dims::Tuple,[fftw_flags=FFTW.ESTIMATE])</code></pre><p>Constructor to set up an operator for evaluating the integrating factor with real-valued parameter <code>a</code>. This can then be applied with the <code>*</code> or `` operation on data of the appropriate size.</p><p>Note that <code>a</code> can be positive, negative, or zero. However, if <code>a</code> is negative, then only the <span>$operation is actually correct; the `*` operation merely returns the identity to avoid excessive (and noisy) calculation. Similarly, if `a` is positive, the$</span> operation returns the identity. Thus, these operations are not inverses of one another. If <code>a</code> is zero, both operations return the identity.</p><p>The <code>dims</code> argument can be replaced with data of type <code>ScalarGridData</code> to specify the size of the domain.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Dual,(6,6));

julia&gt; w[4,4] = 1.0;

julia&gt; E = plan_intfact(1.0,(6,6))
Integrating factor with parameter 1.0 on a (nx = 6, ny = 6) grid

julia&gt; E*w
Nodes{Dual,6,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×6 Array{Float64,2}:
 0.00268447   0.00869352  0.0200715   0.028765    0.0200715   0.00869352
 0.00619787   0.0200715   0.0463409   0.0664124   0.0463409   0.0200715
 0.00888233   0.028765    0.0664124   0.0951774   0.0664124   0.028765
 0.00619787   0.0200715   0.0463409   0.0664124   0.0463409   0.0200715
 0.00268447   0.00869352  0.0200715   0.028765    0.0200715   0.00869352
 0.000828935  0.00268447  0.00619787  0.00888233  0.00619787  0.00268447</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/intfact.jl#L13-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_intfact!" href="#CartesianGrids.plan_intfact!"><code>CartesianGrids.plan_intfact!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_intfact!(a::Real,dims::Tuple,[fftw_flags=FFTW.ESTIMATE][,nthreads=length(Sys.cpu_info())])</code></pre><p>Same as <a href="#CartesianGrids.plan_intfact"><code>plan_intfact</code></a>, but the resulting operator performs an in-place operation on data. The number of threads <code>threads</code> defaults to the number of logical CPU cores on the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/intfact.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_laplacian" href="#CartesianGrids.plan_laplacian"><code>CartesianGrids.plan_laplacian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_laplacian(dims::Tuple,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [factor=1.0],[dx=1.0],[dtype=Float64])</code></pre><p>Constructor to set up an operator for evaluating the discrete Laplacian on dual or primal nodal data of dimension <code>dims</code>. If the optional keyword <code>with_inverse</code> is set to <code>true</code>, then it also sets up the inverse Laplacian (the lattice Green&#39;s function, LGF). These can then be applied, respectively, with <code>*</code> and <code>\</code> operations on data of the appropriate size. The optional parameter <code>factor</code> is a scalar used to multiply the result of the operator and divide the inverse. The optional parameter <code>dx</code> is used in adjusting the uniform value of the LGF to match the behavior of the continuous analog at large distances; this is set to 1.0 by default. The type of data on which to act is floating point by default, but can also be ComplexF64. This is specified with the optional parameter <code>dtype</code></p><p>Instead of the first argument, one can also supply <code>w::Nodes</code> to specify the size of the domain.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = Nodes(Dual,(5,5));

julia&gt; w[3,3] = 1.0;

julia&gt; L = plan_laplacian(5,5;with_inverse=true)
Discrete Laplacian (and inverse) on a (nx = 5, ny = 5) grid acting on Float64 data with spacing 1.0

julia&gt; s = L\w
Nodes{Dual,5,5,Float64} data
Printing in grid orientation (lower left is (1,1))
5×5 Array{Float64,2}:
 0.16707    0.129276     0.106037     0.129276    0.16707
 0.129276   0.0609665   -0.00734343   0.0609665   0.129276
 0.106037  -0.00734343  -0.257343    -0.00734343  0.106037
 0.129276   0.0609665   -0.00734343   0.0609665   0.129276
 0.16707    0.129276     0.106037     0.129276    0.16707

julia&gt; L*s ≈ w
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/laplacian.jl#L210-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.plan_laplacian!" href="#CartesianGrids.plan_laplacian!"><code>CartesianGrids.plan_laplacian!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plan_laplacian!(dims::Tuple,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [factor=1.0][,nthreads=length(Sys.cpu_info())])</code></pre><p>Same as <a href="#CartesianGrids.plan_laplacian"><code>plan_laplacian</code></a>, but operates in-place on data. The number of threads <code>threads</code> defaults to the number of logical CPU cores on the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/laplacian.jl#L255-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_cross!-Union{Tuple{N}, Tuple{ScalarData{N}, VectorData{N}, VectorData{N}}} where N" href="#CartesianGrids.pointwise_cross!-Union{Tuple{N}, Tuple{ScalarData{N}, VectorData{N}, VectorData{N}}} where N"><code>CartesianGrids.pointwise_cross!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_cross!(C::ScalarData,A::VectorData,B::VectorData) -&gt; ScalarData</code></pre><p>Compute the cross product between the vector point data <code>A</code> and <code>B</code> and return the result as scalar data <code>C</code> (treated as an out-of-plane component of a vector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L349-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_cross!-Union{Tuple{N}, Tuple{VectorData{N}, ScalarData{N}, VectorData{N}}} where N" href="#CartesianGrids.pointwise_cross!-Union{Tuple{N}, Tuple{VectorData{N}, ScalarData{N}, VectorData{N}}} where N"><code>CartesianGrids.pointwise_cross!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_cross!(C::VectorData,A::ScalarData/VectorData,B::VectorData/ScalarData) -&gt; VectorData</code></pre><p>Compute the cross product between the point data <code>A</code> and <code>B</code>, one of which is scalar data and treated as an out-of-plane component of a vector, while the other is in-plane vector data, and return the result as vector data <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L361-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_cross-Tuple{Union{Number, ScalarData}, VectorData}" href="#CartesianGrids.pointwise_cross-Tuple{Union{Number, ScalarData}, VectorData}"><code>CartesianGrids.pointwise_cross</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_cross(a::Number/ScalarData,A::VectorData) -&gt; VectorData</code></pre><p>Compute the cross product between the scalar <code>a</code> (treated as an out-of-plane component of a vector) and the planar vector data <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L336-L341">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_cross-Union{Tuple{N}, Tuple{ScalarData{N}, VectorData{N}}} where N" href="#CartesianGrids.pointwise_cross-Union{Tuple{N}, Tuple{ScalarData{N}, VectorData{N}}} where N"><code>CartesianGrids.pointwise_cross</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_cross(A::VectorData/ScalarData,B::ScalarData/VectorData) -&gt; VectorData</code></pre><p>Compute the cross product between the point data <code>A</code> and <code>B</code>, one of which is scalar data and treated as an out-of-plane component of a vector, while the other is in-plane vector data, and return the result as vector data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L390-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_cross-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}}} where N" href="#CartesianGrids.pointwise_cross-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}}} where N"><code>CartesianGrids.pointwise_cross</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_cross(A::VectorData,B::VectorData) -&gt; ScalarData</code></pre><p>Compute the cross product between the vector point data <code>A</code> and <code>B</code> and return the result as scalar data (treated as an out-of-plane component of a vector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L380-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{ScalarData{N}, VectorData{N}, VectorData{N}}} where N" href="#CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{ScalarData{N}, VectorData{N}, VectorData{N}}} where N"><code>CartesianGrids.pointwise_dot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_dot!(C::ScalarData,A::VectorData,B::VectorData) -&gt; ScalarData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code> and return the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L405-L410">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}, TensorData{N}}} where N" href="#CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}, TensorData{N}}} where N"><code>CartesianGrids.pointwise_dot!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_dot!(C::VectorData,A::TensorData/VectorData,B::VectorData/TensorData) -&gt; VectorData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code>, where one is <code>TensorData</code> and the other is <code>VectorData</code> and return the result as <code>VectorData</code> in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L426-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N}, TensorData{N}}} where N" href="#CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N}, TensorData{N}}} where N"><code>CartesianGrids.pointwise_dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_dot(A::TensorData/VectorData,B::VectorData/TensorData) -&gt; VectorData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code>, where one is <code>TensorData</code> and the other is <code>VectorData</code> and return the result as <code>VectorData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L439-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}}} where N" href="#CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N}, VectorData{N}}} where N"><code>CartesianGrids.pointwise_dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_dot(A::VectorData,B::VectorData) -&gt; ScalarData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code> and return the result as <code>ScalarData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L416-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.pointwise_tensorproduct!-Union{Tuple{N}, Tuple{TensorData{N}, VectorData{N}, VectorData{N}}} where N" href="#CartesianGrids.pointwise_tensorproduct!-Union{Tuple{N}, Tuple{TensorData{N}, VectorData{N}, VectorData{N}}} where N"><code>CartesianGrids.pointwise_tensorproduct!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pointwise_tensorproduct!(pq::TensorData,p::VectorData,q::VectorData) -&gt; TensorData</code></pre><p>Calculate the element by element tensor product between vectors <code>p</code> and <code>q</code>, returning data in <code>pq</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L283-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.product" href="#CartesianGrids.product"><code>CartesianGrids.product</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">product(p::PointData,q::PointData) -&gt; PointData
(∘)(p::PointData,q::PointData) -&gt; PointData</code></pre><p>Compute the Hadamard (i.e. element by element) product of point data data <code>p</code> and <code>q</code>. Works similarly to <code>product!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L251-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.product!-Union{Tuple{N}, Tuple{PointData{N}, PointData{N}, PointData{N}}} where N" href="#CartesianGrids.product!-Union{Tuple{N}, Tuple{PointData{N}, PointData{N}, PointData{N}}} where N"><code>CartesianGrids.product!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">product!(out::PointData,p::PointData,q::PointData)</code></pre><p>Compute the Hadamard (i.e. element by element) product of point data data <code>p</code> and <code>q</code> and return the result in <code>out</code>. Note that <code>p</code> and <code>q</code> can be of mixed type (scalar, vector, tensor), as long as one of them is a scalar. Also, <code>out</code> must have element type that is consistent with the promoted type of <code>p</code> and <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fcs = ScalarData(5,dtype=ComplexF64);

julia&gt; fill!(fcs,2im)
5 points of scalar-valued Complex{Float64} data
5-element Array{Complex{Float64},1}:
 0.0 + 2.0im
 0.0 + 2.0im
 0.0 + 2.0im
 0.0 + 2.0im
 0.0 + 2.0im

julia&gt; frt = TensorData(fcs,dtype=Float64);

julia&gt; fill!(frt,1.0)
5 points of tensor-valued Float64 data dudx, dudy, dvdx, dvdy
5×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; out = similar(frt,element_type=ComplexF64);

julia&gt; product!(out,frt,fcs)
5 points of tensor-valued Complex{Float64} data dudx, dudy, dvdx, dvdy
5×4 Array{Complex{Float64},2}:
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L140-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.product!-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:GridData" href="#CartesianGrids.product!-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:GridData"><code>CartesianGrids.product!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">product!(out::GridData,p::GridData,q::GridData)</code></pre><p>Compute the Hadamard (i.e. element by element) product of grid data <code>p</code> and <code>q</code> (of the same type) and return the result in <code>out</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Edges(Dual,(8,6));

julia&gt; out = p = deepcopy(q);

julia&gt; q.u[3,2] = 0.3;

julia&gt; p.u[3,2] = 0.2;

julia&gt; product!(out,p,q)
Edges{Dual,8,6,Float64} data
u (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.06  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
v (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/basicoperations.jl#L100-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.product-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GridData" href="#CartesianGrids.product-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GridData"><code>CartesianGrids.product</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">product(p::Edges/Nodes,q::Edges/Nodes) --&gt; Edges/Nodes</code></pre><p>Compute the Hadamard product of edge or nodal (primal or dual) data <code>p</code> and <code>q</code> and return the result. This operation can also be carried out with the <code>∘</code> operator:</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Edges(Dual,(8,6));

julia&gt; p = deepcopy(q);

julia&gt; q.u[3,2] = 0.3;

julia&gt; p.u[3,2] = 0.2;

julia&gt; p∘q
Edges{Dual,8,6,Float64} data
u (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.06  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
v (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/basicoperations.jl#L145-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.tensorproduct!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY}, Edges{C, NX, NY}, Edges{C, NX, NY}, EdgeGradient{C, D, NX, NY}, EdgeGradient{C, D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.tensorproduct!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY}, Edges{C, NX, NY}, Edges{C, NX, NY}, EdgeGradient{C, D, NX, NY}, EdgeGradient{C, D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.tensorproduct!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tensorproduct!(q::EdgeGradient,u::Edges,v::Edges,ut::EdgeGradient,vt::EdgeGradient)</code></pre><p>In-place tensor product of <code>u</code> and <code>v</code>, with the result returned in <code>q</code>. The <code>ut</code> and <code>vt</code> are supplied as temporary storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/basicoperations.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.test_cputime-Tuple{Any, Any, Any}" href="#CartesianGrids.test_cputime-Tuple{Any, Any, Any}"><code>CartesianGrids.test_cputime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_cputime(nx,ny,nthreads_max;[nsamp=1][,testtype=:laplacian][,kwargs]) -&gt; Float64, Float64</code></pre><p>Evaluate a sample FFT-based problem with the given size of grid <code>nx</code> x <code>ny</code> and the provided maximum number of threads <code>nthreads_max</code>. Returns the mean and standard deviation of the computational time. The optional argument <code>nsamp</code> can be used to perform an average timing over multiple samples. The test type is specified with the <code>testtype</code> optional argument. The default test is inversion of a Laplacian (<code>:laplacian</code>). Other options are <code>:intfact</code> and <code>:helmholtz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L171-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CartesianGrids.volume-Union{Tuple{PhysicalGrid{ND}}, Tuple{ND}} where ND" href="#CartesianGrids.volume-Union{Tuple{PhysicalGrid{ND}}, Tuple{ND}} where ND"><code>CartesianGrids.volume</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">volume(g::PhysicalGrid) -&gt; Float64</code></pre><p>Return the volume (or area) of the physical grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/physical/physicalgrid.jl#L276-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Edges{C, NX, NY}, Edges{C, NX, NY}}} where {C&lt;:CartesianGrids.CellType, NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Edges{C, NX, NY}, Edges{C, NX, NY}}} where {C&lt;:CartesianGrids.CellType, NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::Edges{Dual/Primal},p2::Edges{Dual/Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of edge data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY}, EdgeGradient{C, D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY}, EdgeGradient{C, D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::EdgeGradient{Dual/Primal},p2::EdgeGradient{Dual/Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of edge gradient data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY}, Nodes{Dual, NX, NY}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::Nodes{Dual},p2::Nodes{Dual}) -&gt; Real</code></pre><p>Computes the inner product between two sets of dual node data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY}, Nodes{Primal, NX, NY}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY}, Nodes{Primal, NX, NY}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::Nodes{Primal},p2::Nodes{Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of primal node data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Dual, NX, NY}, XEdges{Dual, NX, NY}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Dual, NX, NY}, XEdges{Dual, NX, NY}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::XEdges{Dual},p2::XEdges{Dual}) -&gt; Real</code></pre><p>Computes the inner product between two sets of dual x-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Primal, NX, NY}, XEdges{Primal, NX, NY}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Primal, NX, NY}, XEdges{Primal, NX, NY}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::XEdges{Primal},p2::XEdges{Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of primal x-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Dual, NX, NY}, YEdges{Dual, NX, NY}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Dual, NX, NY}, YEdges{Dual, NX, NY}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::YEdges{Dual},p2::YEdges{Dual}) -&gt; Real</code></pre><p>Computes the inner product between two sets of dual y-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Primal, NX, NY}, YEdges{Primal, NX, NY}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Primal, NX, NY}, YEdges{Primal, NX, NY}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(p1::YEdges{Primal},p2::YEdges{Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of primal y-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L112-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, TensorData}} where T&lt;:Number" href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, TensorData}} where T&lt;:Number"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(A::Tuple{T,T},B::TensorData) where {T&lt;:Number} -&gt; VectorData
⋅(A::Tuple{T,T},B::TensorData) where {T&lt;:Number} -&gt; VectorData</code></pre><p>Computes the dot product between the tuple <code>A</code> and the elements of a tensor <code>B</code> on a set of points and returns vector data on the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L515-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, VectorData}} where T&lt;:Number" href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, VectorData}} where T&lt;:Number"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dot(A::Tuple{T,T},B::VectorData) where {T&lt;:Number} -&gt; ScalarData
⋅(A::Tuple{T,T},B::VectorData) where {T&lt;:Number} -&gt; ScalarData</code></pre><p>Computes the dot product between the tuple <code>v</code> and the elements of a tensor <code>B</code> on a set of points and returns scalar data on the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L501-L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{GridData}" href="#LinearAlgebra.norm-Tuple{GridData}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(p::GridData) -&gt; Real</code></pre><p>Computes the L2 norm of data on a grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/innerproducts.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.transpose!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY}, EdgeGradient{C, D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#LinearAlgebra.transpose!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY}, EdgeGradient{C, D, NX, NY}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>LinearAlgebra.transpose!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose!(pt::EdgeGradient,p::EdgeGradient)</code></pre><p>In-place element-by-element transpose of <code>EdgeGradient</code> <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/gridoperations/basicoperations.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.transpose!-Union{Tuple{N}, Tuple{TensorData{N}, TensorData{N}}} where N" href="#LinearAlgebra.transpose!-Union{Tuple{N}, Tuple{TensorData{N}, TensorData{N}}} where N"><code>LinearAlgebra.transpose!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose!(pt::TensorData,p::TensorData)</code></pre><p>In-place element-by-element transpose of <code>TensorData</code> <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/3ba8719aedf5f398f86fa5febb3c3d6703fb0e53/src/points/basicpointoperations.jl#L307-L311">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../immersed/">« Immersed data and their operations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 28 April 2025 07:16">Monday 28 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
