<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · CartesianGrids.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CartesianGrids.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../overview/">Overview of staggered grids</a></li><li><a class="tocitem" href="../fielddata/">Setting up field data</a></li><li><a class="tocitem" href="../finitediff/">Mimetic calculus on grid data</a></li><li><a class="tocitem" href="../immersed/">Immersed data and their operations</a></li><li class="is-active"><a class="tocitem" href>Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/master/docs/src/manual/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.CircularConvolution" href="#CartesianGrids.CircularConvolution"><code>CartesianGrids.CircularConvolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CircularConvolution{M, N, T}</code></pre><p>A preplanned, circular convolution operator on an M × N matrix of data of type T</p><p><strong>Fields</strong></p><ul><li><code>Ĝ</code>: DFT coefficients of the convolution kernel</li><li><code>F</code>: preplanned rFFT operator</li><li><code>F⁻¹</code>: preplanned irFFT operator</li><li><code>paddedSpace</code>: scratch space to zero-pad the input matrix</li><li><code>Â</code>: scratch space to store the DFT coefficients of the zero-padded input matrix</li></ul><p><strong>Constructors:</strong></p><ul><li><code>CircularConvolution(G::Matrix{T})</code></li></ul><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; G = repeat(1.0:3,1,4)
3×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 2.0  2.0  2.0  2.0
 3.0  3.0  3.0  3.0

julia&gt; C = CircularConvolution(G)
Circular convolution on a 3 × 4 matrix of data type Float64

julia&gt; C*reshape(1:12, 3, 4)
3×4 Array{Int64,2}:
 164  164  164  164
 130  130  130  130
 148  148  148  148</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/convolution.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.DDF-Tuple{}" href="#CartesianGrids.DDF-Tuple{}"><code>CartesianGrids.DDF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DDF([ddftype=Roma],[dx=1.0])</code></pre><p>Construct a discrete delta function operator. This is generally only needed internally by the <code>Regularize</code> operator, so the user doesn&#39;t have much need for accessing this directly. The default DDF is the <code>Roma</code> function, which has a support of 3 grid cells. Other choices are the <code>Goza</code> operator, which is a truncated Gaussian with 28 cells support, and the <code>Witchhat</code>, which has 2 cells support. The resulting operator is evaluated with one, two or three coordinate arguments, producing, respectively, 1-d, 2-d, or 3-d smeared delta functions. It can also be called with the usual Julia vectorized dot notation with arrays of arguments. The optional cell spacing argument <code>dx</code> rescales the coordinates by this spacing, and the result is also rescaled by this spacing (raised to the number of dimensions). This spacing argument defaults to 1.0.</p><pre><code class="language-julia-repl">julia&gt; ddf = DDF(ddftype=Roma)
Discrete delta function operator of type CartesianGrids.Roma, with spacing 1.0

julia&gt; ddf(1)
0.16666666666666666

julia&gt; ddf(-1)
0.16666666666666666

julia&gt; ddf.([-1,0,1])
3-element Array{Float64,1}:
 0.16666666666666666
 0.6666666666666666
 0.16666666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/ddf.jl#L7-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.EdgeGradient" href="#CartesianGrids.EdgeGradient"><code>CartesianGrids.EdgeGradient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EdgeGradient</code></pre><p><code>EdgeGradient</code> is a wrapper for tensor-valued data that lie partly at the nodes of dual cells and primary cells. <code>EdgeGradient</code> type data have fields <code>dudx</code>, <code>dudy</code>, <code>dvdx</code>, <code>dvdy</code> for the components of the tensor field. The diagonal components lie at one set of nodes (e.g. Primal), and the offdiagonal at the other set (e.g. Dual).</p><p><strong>Constructors</strong></p><ul><li><code>EdgeGradient(C,dims)</code> creates a tensor field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code>. Note that <code>dims</code> represent the number of dual cells on the grid.</li><li><code>EdgeGradient(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/fields/collections.jl#L115-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.Edges" href="#CartesianGrids.Edges"><code>CartesianGrids.Edges</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Edges</code></pre><p><code>Edges</code> is a wrapper for vector-valued data that lie at the faces of either dual cells or primary cells. <code>Edges</code> type data have fields <code>u</code> and <code>v</code> for the components of the vector field. These are the normal components of the vector field on the vertical and horizontal faces of the corresponding cell.</p><p><strong>Constructors</strong></p><ul><li><code>Edges(C,dims)</code> creates a vector field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code>. Note that <code>dims</code> represent the number of dual cells on the grid.</li><li><code>Edges(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/fields/collections.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.EmptySpatialField" href="#CartesianGrids.EmptySpatialField"><code>CartesianGrids.EmptySpatialField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EmptySpatialField()</code></pre><p>Create a blank spatial field. This is primarily useful for initializing a sum of spatial fields.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; g = EmptySpatialField()
EmptySpatialField()

julia&gt; g(2,3)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/generatefields.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.GeneratedField" href="#CartesianGrids.GeneratedField"><code>CartesianGrids.GeneratedField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeneratedField(d::GridData,field::AbstractSpatialField...,grid::PhysicalGrid)</code></pre><p>Create an instance of a spatial field function <code>field</code> on scalar grid data <code>d</code>, based on a grid <code>grid</code>. After creating the instance <code>g = GeneratedField(d,field,grid)</code>, then the resulting grid data can be accessed by typing <code>g()</code>. For vector grid data, a separate <code>field</code> must be supplied for each component.</p><p>If the fields are time dependent, then you can also evaluate <code>g(t)</code> at the desired time. The time argument is ignored if the fields are static.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/generatefields.jl#L151-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.InterpolationMatrix" href="#CartesianGrids.InterpolationMatrix"><code>CartesianGrids.InterpolationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterpolationMatrix(H::Regularize,u::CellData,f::PointData) -&gt; Emat</code></pre><p>Construct and store a matrix representation of interpolation associated with <code>H</code> for data of type <code>u</code> to data of type <code>f</code>. The resulting matrix <code>Emat</code> can then be used to apply on grid data of type <code>u</code> to interpolate it to point data of type <code>f</code>, using <code>mul!(f,Emat,u)</code>. It can also be used as just <code>Emat*u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/regularization.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.ModulatedField" href="#CartesianGrids.ModulatedField"><code>CartesianGrids.ModulatedField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModulatedField(g::GeneratedField,modfcn::Abstract1DProfile)</code></pre><p>Create a time-modulated form of a generated spatial field, useful for introducing a forcing field onto the grid. The supplied field <code>g</code> is modulated by a function <code>modfcn</code> with a specified profle shape. The resulting object can be evaluated with a single argument (time) and returns a <code>GridData</code> type object of the same type contained in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/generatefields.jl#L227-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.NodePair" href="#CartesianGrids.NodePair"><code>CartesianGrids.NodePair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodePair</code></pre><p><code>NodePair</code> is a wrapper for vector-valued data that lie at the nodes of dual cells and primal cells. <code>NodePair</code> type data have fields <code>u</code> and <code>v</code> for the components of the vector field. These are the normal components of a vector field on nodes that form the faces of a virtual cell centered at one of the faces of the primal cell.</p><p><strong>Constructors</strong></p><ul><li><code>NodePair(C,dims)</code> creates a vector field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code>. Note that <code>dims</code> represent the number of dual cells on the grid.</li><li><code>NodePair(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/fields/collections.jl#L174-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.Nodes" href="#CartesianGrids.Nodes"><code>CartesianGrids.Nodes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Nodes</code></pre><p><code>Nodes</code> is a wrapper for scalar-valued data that lie at the centers of either dual cells or primary cells. A <code>Nodes</code> type can be accessed by indexing like any other array, and allows the use of <a href="#Base.size-Tuple{PhysicalGrid, Int64}"><code>size</code></a>, <a href="manual/@ref"><code>similar</code></a>, <a href="manual/@ref"><code>zero</code></a>.</p><p><strong>Constructors</strong></p><ul><li><code>Nodes(C,dims)</code> creates a field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code> (a tuple). Note that <code>dims</code> represent the number of dual cells on the grid, even if <code>C</code> is <code>Primal</code>.</li><li><code>Nodes(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/fields/scalargrid.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.PhysicalGrid-Tuple{Tuple{Real, Real}, Tuple{Real, Real}, Float64}" href="#CartesianGrids.PhysicalGrid-Tuple{Tuple{Real, Real}, Tuple{Real, Real}, Float64}"><code>CartesianGrids.PhysicalGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PhysicalGrid(xlim::Tuple{Real,Real},ylim::Tuple{Real,Real},Δx::Float64)</code></pre><p>Constructor to set up a grid connected to physical space. The region to be discretized by the grid is defined by the limits <code>xlim</code> and <code>ylim</code>, and the cell spacing (uniform and indentical in each direction) is specified by <code>Δx</code>. The constructor uses this information to determine the number of cells in each direction, expanding the given range if necessary to accommodate an integer number. It also pads each side with a ghost cell. It also determines the indices corresponding to the corner of the cell to which the physical origin corresponds. Note that the corner corresponding to the lowest limit in each direction has indices (1,1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L50-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.RegularizationMatrix" href="#CartesianGrids.RegularizationMatrix"><code>CartesianGrids.RegularizationMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizationMatrix(H::Regularize,f::PointData,u::CellData) -&gt; Hmat</code></pre><p>Construct and store a matrix representation of regularization associated with <code>H</code> for data of type <code>f</code> to data of type <code>u</code>. The resulting matrix <code>Hmat</code> can then be used to apply on point data of type <code>f</code> to regularize it to grid data of type <code>u</code>, using <code>mul!(u,Hmat,f)</code>. It can also be used as just <code>Hmat*f</code>.</p><p>If <code>H</code> is a symmetric regularization and interpolation operator, then this actually returns a tuple <code>Hmat, Emat</code>, where <code>Emat</code> is the interpolation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/regularization.jl#L197-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.Regularize-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T&lt;:Real" href="#CartesianGrids.Regularize-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T}} where T&lt;:Real"><code>CartesianGrids.Regularize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Regularize(x,y,dx,[ddftype=Yang3],[graddir=0],[I0=(1,1)], [weights=1.0], [filter=false],
                   [issymmetric=false])</code></pre><p>Constructor to set up an operator for regularizing and interpolating data from/to points immersed in the grid to/from fields on the grid itself. The supplied <code>x</code> and <code>y</code> represent physical coordinates of the immersed points, and <code>dx</code> denotes a uniform physical cell size of the grid. The separate arguments <code>x</code> and <code>y</code> can be replaced by a single argument <code>X</code> of type <code>VectorData</code> holding the coordinates.</p><p>The operations of regularization and interpolation are carried out with a discrete delta function (ddf), which defaults to the type <code>Yang3</code>. Others are also possible, such as <code>Roma</code>, <code>Goza</code> or <code>M3</code>. The optional argument <code>graddir</code>, if set to 1 or 2, will generate an interpolation operator that evaluates the negative of the respective component of the gradient of a grid field at the immersed points. The default value of this argument is 0, which simply interpolates. Note that the regularization form of this gradient type is also possible.</p><p>The optional tuple <code>I0</code> represents the indices of the primary node that coincides with <code>(x,y) = (0,0)</code>. This defaults to <code>(1,1)</code>, which leaves one layer of ghost (dual) cells and sets the physical origin in the lower left corner of the grid of interior dual cells.</p><p>Another optional parameter, <code>weights</code>, sets the weight of each point in the regularization. This would generally be set with, say, the differential arc length for regularization of data on a curve. It can be a vector (of the same length as x and y) or a scalar if uniform. It defaults to 1.0.</p><p>The optional Boolean parameter <code>filter</code> can be set to <code>true</code> if it is desired to apply filtering (see Goza et al, J Comput Phys 2016) to the grid data before interpolating. This is generally only used in the context of preconditioning the solution for forces on the immersed points.</p><p>If the optional Boolean parameter <code>issymmetric</code> is set to <code>true</code>, then the regularization and interpolation are constructed to be transposes of each other. Note that this option overrides any supplied weights. The default of this parameter is <code>false</code>.</p><p>The resulting operator can be used in either direction, regularization and interpolation, with the first argument representing the <em>target</em> (the entity to regularize/interpolate to), and the second argument the <em>source</em> (the entity to regularize/interpolate from). The regularization does not use the filtering option.</p><p><strong>Example</strong></p><p>In the example below, we set up a 12 x 12 grid. Using the default value for <code>I0</code> and setting <code>dx = 0.1</code>, the physical dimensions of the non-ghost part of the grid are 1.0 x 1.0. Three points are set up in the interior, and a vector field is assigned to them, with the x component of each of them set to 1.0. These data are regularized to a field of primal edges on the grid, using the Roma DDF kernel.</p><pre><code class="language-julia-repl">julia&gt; x = [0.25,0.75,0.25]; y = [0.75,0.25,0.25];

julia&gt; X = VectorData(x,y);

julia&gt; q = Edges(Primal,(12,12));

julia&gt; dx = 0.1;

julia&gt; H = Regularize(x,y,dx;ddftype=Roma)
Regularization/interpolation operator with non-filtered interpolation
  DDF type CartesianGrids.Roma
  3 points in grid with cell area 0.01

julia&gt; f = VectorData(X);

julia&gt; fill!(f.u,1.0);

julia&gt; H(q,f)
Edges{Primal,12,12,Float64} data
u (in grid orientation)
11×12 Array{Float64,2}:
 0.0  0.0  0.0       0.0     0.0      …  0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     0.0       0.0     0.0      0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0      …  0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     8.33333  33.3333  8.33333  0.0  0.0
 0.0  0.0  8.33333  33.3333  8.33333     8.33333  33.3333  8.33333  0.0  0.0
 0.0  0.0  0.0       0.0     0.0         0.0       0.0     0.0      0.0  0.0
 0.0  0.0  0.0       0.0     0.0      …  0.0       0.0     0.0      0.0  0.0
v (in grid orientation)
12×11 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/regularization.jl#L29-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.ScalarData" href="#CartesianGrids.ScalarData"><code>CartesianGrids.ScalarData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarData &lt;: PointData</code></pre><p>A wrapper for a one-dimensional array of scalar-valued data. The resulting wrapper can be indexed in the same way as the array itself.</p><p><strong>Constructors</strong></p><ul><li><code>ScalarData(d::AbstractVector[,dtype=Float64])</code> constructs a wrapper for the one-dimensional array of data <code>d</code></li><li><code>ScalarData(n::Int)</code> constructs a wrapper for an array of zeros of length <code>n</code>.</li><li><code>ScalarData(x::PointData)</code> constructs a wrapper for an array of zeros of the  same length as that wrapped by <code>x</code>.</li><li><code>ScalarData(n::Int,dtype=ComplexF64)</code> constructs a wrapper for complex-valued data.</li><li><code>ScalarData(x::PointData,dtype=ComplexF64)</code> constructs a wrapper for an array of  complex zeros of the same length as that wrapped by <code>x</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f = ScalarData(10);

julia&gt; f[5] = 1.0;

julia&gt; f
10 points of scalar-valued Float64 data
10-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/points.jl#L6-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.SpatialGaussian" href="#CartesianGrids.SpatialGaussian"><code>CartesianGrids.SpatialGaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpatialGaussian(σx,σy,x0,y0,A[,derivdir=0])</code></pre><p>Set up a spatial field in the form of a Gaussian centered at <code>x0,y0</code> with radii <code>σx</code> and <code>σy</code> in the respective directions and amplitude <code>A</code>. If the optional parameter <code>deriv</code> is set to 1 or 2, then it returns the first derivative of a Gaussian in that direction (<code>x</code> or <code>y</code>, respectively).</p><p><code>SpatialGaussian(σx,σy,x0,y0,A,u,v[,derivdir=0])</code> generates a Gaussian that convects at velocity <code>(u,v)</code>. It can be evaluated with an additional argument for time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/generatefields.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.TensorData" href="#CartesianGrids.TensorData"><code>CartesianGrids.TensorData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TensorData &lt;: PointData</code></pre><p>A wrapper for a one-dimensional array of 2x2 tensor-valued data, with fields <code>dudx</code>, <code>dudy</code>, <code>dvdx</code>, <code>dvdy</code>. The resulting wrapper can be indexed as though these four components are stacked on top of each other.</p><p><strong>Constructors</strong></p><ul><li><code>TensorData(d::AbstractVector[,dtype=Float64])</code> constructs a wrapper for the one-dimensional array of data <code>d</code>, splitting <code>d</code> into the four components evenly.</li><li><code>TensorData(dudx,dudy,dvdx,dvdy)</code> constructs a wrapper for the tensor components data, each of type <code>AbstractVector</code></li><li><code>TensorData(n::Int)</code> constructs a wrapper with zeros of length <code>n</code> for all components.</li><li><code>TensorData(x::PointData[,dtype=Float64])</code> constructs a wrapper for zero components of the  same length as that wrapped by <code>x</code>.</li></ul><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/points.jl#L147-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.VectorData" href="#CartesianGrids.VectorData"><code>CartesianGrids.VectorData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorData &lt;: PointData</code></pre><p>A wrapper for a one-dimensional array of two-component vector-valued data. The resulting wrapper can be indexed as though the first component and second component are stacked on top of each other.</p><p><strong>Constructors</strong></p><ul><li><code>VectorData(d::AbstractVector[,dtype=Float64])</code> constructs a wrapper for the one-dimensional array of data <code>d</code>, splitting <code>d</code> into the <code>u</code> and <code>v</code> components evenly.</li><li><code>VectorData(u::AbstractVector,v::AbstractVector)</code> constructs a wrapper for the vector components data <code>u</code> and <code>v</code>.</li><li><code>VectorData(n::Int)</code> constructs a wrapper with zeros of length <code>n</code> for both components.</li><li><code>VectorData(x::PointData)</code> constructs a wrapper for zero components of the  same length as that wrapped by <code>x</code>.</li><li><code>VectorData(n::Int,dtype=ComplexF64)</code> constructs a wrapper with complex-valued zeros  of length <code>n</code> for both components.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f = VectorData(10,dtype=ComplexF64);

julia&gt; f.v[1:5] = 1:5;

julia&gt; f
10 points of vector-valued Complex{Float64} data
10×2 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im
 0.0+0.0im  2.0+0.0im
 0.0+0.0im  3.0+0.0im
 0.0+0.0im  4.0+0.0im
 0.0+0.0im  5.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im

julia&gt; f[7] = 1im; f[18] = 0.2;

julia&gt; f
10 points of vector-valued Complex{Float64} data
10×2 Array{Complex{Float64},2}:
 0.0+0.0im  1.0+0.0im
 0.0+0.0im  2.0+0.0im
 0.0+0.0im  3.0+0.0im
 0.0+0.0im  4.0+0.0im
 0.0+0.0im  5.0+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+1.0im  0.0+0.0im
 0.0+0.0im  0.2+0.0im
 0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/points.jl#L59-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.XEdges" href="#CartesianGrids.XEdges"><code>CartesianGrids.XEdges</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">XEdges</code></pre><p><code>XEdges</code> is a wrapper for scalar-valued data that lie at the centers of either dual cells or primary cells. A <code>XEdges</code> type can be accessed by indexing like any other array, and allows the use of <a href="#Base.size-Tuple{PhysicalGrid, Int64}"><code>size</code></a>, <a href="manual/@ref"><code>similar</code></a>, <a href="manual/@ref"><code>zero</code></a>.</p><p><strong>Constructors</strong></p><ul><li><code>XEdges(C,dims)</code> creates a field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code> (a tuple). Note that <code>dims</code> represent the number of dual cells on the grid, even if <code>C</code> is <code>Primal</code>.</li><li><code>XEdges(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/fields/scalargrid.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.YEdges" href="#CartesianGrids.YEdges"><code>CartesianGrids.YEdges</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">YEdges</code></pre><p><code>YEdges</code> is a wrapper for scalar-valued data that lie at the centers of either dual cells or primary cells. A <code>YEdges</code> type can be accessed by indexing like any other array, and allows the use of <a href="#Base.size-Tuple{PhysicalGrid, Int64}"><code>size</code></a>, <a href="manual/@ref"><code>similar</code></a>, <a href="manual/@ref"><code>zero</code></a>.</p><p><strong>Constructors</strong></p><ul><li><code>YEdges(C,dims)</code> creates a field of zeros in cells of type <code>C</code> (where <code>C</code> is either <code>Dual</code> or <code>Primal</code>), on a grid of dimensions <code>dims</code> (a tuple). Note that <code>dims</code> represent the number of dual cells on the grid, even if <code>C</code> is <code>Primal</code>.</li><li><code>YEdges(C,w)</code> performs the same construction, but uses existing field data <code>w</code> of <code>GridData</code> type to determine the size of the grid.</li><li>Adding the <code>dtype=</code> keyword allows the data type of the field data to be changed. The default is <code>Float64</code>, but can be changed to, e.g., <code>ComplexF64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/fields/scalargrid.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#Base.:*-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(*)(p::VectorData,q::VectorData) -&gt; TensorData</code></pre><p>Calculate the element by element tensor product between vectors <code>p</code> and <code>q</code>, returning <code>TensorData</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{AbstractSpatialField, CartesianGrids.AddedFields}" href="#Base.:+-Tuple{AbstractSpatialField, CartesianGrids.AddedFields}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p₁::AbstractSpatialField + p₂::AbstractSpatialField</code></pre><p>Add the fields so that <code>(p₁ + p₂)(x,y) = p₁(x,y) + p₂(x,y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/generatefields.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{VectorData, Tuple{T, T}}} where T&lt;:Number" href="#Base.:+-Union{Tuple{T}, Tuple{VectorData, Tuple{T, T}}} where T&lt;:Number"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(+)(X::VectorData,a::Tuple{T,T}) where {T&lt;:Number} -&gt; VectorData
(-)(X::VectorData,a::Tuple{T,T}) where {T&lt;:Number} -&gt; VectorData</code></pre><p>Adds or subtracts the tuple <code>a</code> component by component to each element of <code>X</code>. All data in <code>a</code> are converted to Float64. Can also switch the arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f = VectorData(5);

julia&gt; f + (2,3)
5 points of vector-valued Float64 data
5×2 Array{Float64,2}:
 2.0  3.0
 2.0  3.0
 2.0  3.0
 2.0  3.0
 2.0  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L362-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Union{Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any, Any}} where {NX, NY}" href="#Base.exp-Union{Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any, Any}} where {NX, NY}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(L::Laplacian,a[,Nodes(Dual)])</code></pre><p>Create the integrating factor exp(L*a). The default size of the operator is the one appropriate for dual nodes; another size can be specified by supplying grid data in the optional third argument. Note that, if <code>L</code> contains a factor, it scales the exponent with this factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/intfact.jl#L113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{PhysicalGrid}" href="#Base.length-Tuple{PhysicalGrid}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(g::PhysicalGrid,d::Int) -&gt; Int</code></pre><p>Return the total number of cells in grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{PhysicalGrid, Int64}" href="#Base.size-Tuple{PhysicalGrid, Int64}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(g::PhysicalGrid,d::Int) -&gt; Int</code></pre><p>Return the number of cells in direction <code>d</code> in grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{PhysicalGrid}" href="#Base.size-Tuple{PhysicalGrid}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(g::PhysicalGrid) -&gt; Tuple</code></pre><p>Return a tuple of the number of cells in all directions in grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.transpose-Tuple{TensorData}" href="#Base.transpose-Tuple{TensorData}"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transpose(p::TensorData) -&gt; TensorData</code></pre><p>Element-by-element transpose of <code>TensorData</code> <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.transpose-Union{Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#Base.transpose-Union{Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>Base.transpose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transpose(p::EdgeGradient) -&gt; EdgeGradient</code></pre><p>Element-by-element transpose of <code>EdgeGradient</code> <code>p</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/basicoperations.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.cellsize-Tuple{PhysicalGrid}" href="#CartesianGrids.cellsize-Tuple{PhysicalGrid}"><code>CartesianGrids.cellsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cellsize(g::PhysicalGrid) -&gt; Float64</code></pre><p>Return the grid cell size of system <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.convective_derivative!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.convective_derivative!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.convective_derivative!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convective_derivative!(out,q)</code></pre><p>Compute the convective derivative of <code>q</code> in the form <span>$u\cdot\nabla u$</span> and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L167-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.convective_derivative_rot!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.convective_derivative_rot!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.convective_derivative_rot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convective_derivative_rot!(out,q)</code></pre><p>Compute the rotational form of the convective derivative of <code>q</code> in the form <span>$\frac{1}{2}\nabla|u|^2-u\times(\nabla\times u)$</span> and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.coordinates" href="#CartesianGrids.coordinates"><code>CartesianGrids.coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coordinates(w::GridData;[dx=1.0],[I0=(1,1)])</code></pre><p>Return a tuple of the ranges of the physical coordinates in each direction for grid data <code>w</code>. If <code>w</code> is of <code>Nodes</code> type, then it returns a tuple of the form <code>xg,yg</code>. If <code>w</code> is of <code>Edges</code> or <code>NodePair</code> type, then it returns a tuple of the form <code>xgu,ygu,xgv,ygv</code>.</p><p>The optional keyword argument <code>dx</code> sets the grid spacing; its default is <code>1.0</code>. The optional keyword <code>I0</code> accepts a tuple of integers to set the index pair of the primal nodes that coincide with the origin. The default is <code>(1,1)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Dual,(12,22));

julia&gt; xg, yg = coordinates(w,dx=0.1)
(-0.05:0.1:1.05, -0.05:0.1:2.0500000000000003)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.coordinates-Tuple{Any, PhysicalGrid}" href="#CartesianGrids.coordinates-Tuple{Any, PhysicalGrid}"><code>CartesianGrids.coordinates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coordinates(w::Nodes/Edges,g::PhysicalGrid) -&gt; Range</code></pre><p>Return coordinate data range for type of <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.cross!-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#CartesianGrids.cross!-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>CartesianGrids.cross!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cross!(C::ScalarData,A::VectorData,B::VectorData) -&gt; ScalarData</code></pre><p>Compute the cross product between the vector point data <code>A</code> and <code>B</code> and return the result as scalar data <code>C</code> (treated as an out-of-plane component of a vector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L284-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.curl!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#CartesianGrids.curl!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>CartesianGrids.curl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">curl!(q::Edges{Primal},w::Nodes{Dual})</code></pre><p>Evaluate the discrete curl of <code>w</code> and return it as <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Dual,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; q = Edges(Primal,w);

julia&gt; curl!(q,w)
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  -1.0  1.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.curl-Union{Tuple{Nodes{Dual, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T)}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}" href="#CartesianGrids.curl-Union{Tuple{Nodes{Dual, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T)}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}"><code>CartesianGrids.curl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">curl(w::Nodes{Dual}) --&gt; Edges{Primal}</code></pre><p>Evaluate the discrete curl of <code>w</code>. Another way to perform this operation is to construct a <code>Curl</code> object and apply it with <code>*</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; C = Curl();

julia&gt; w = Nodes(Dual,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; C*w
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0  -1.0  1.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L51-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.curl_cross!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.curl_cross!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.curl_cross!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">curl_cross!(out,a,b)</code></pre><p>Compute the curl of the cross product of <code>a</code> and <code>b</code>, <span>$\nabla\times(a\times b)$</span>, and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L139-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.diff!" href="#CartesianGrids.diff!"><code>CartesianGrids.diff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diff!(out:ScalarGridData,in::ScalarGridData) -&gt; ScalarGridData</code></pre><p>Return the 1-d central finite difference of scalar grid data <code>in</code> in scalar grid data <code>out</code>. Either <code>in</code> or <code>out</code> must be edge component data and the other must be node data. The direction of differencing is determined by the relationship of <code>in</code> and <code>out</code>. For example, if <code>in</code> is dual nodes (cell by cell) and <code>out</code> is primal x-edge components (cell by edge), then the differencing takes place in the y direction, since they are different types in this direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/differencing1d.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.directional_derivative!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.directional_derivative!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.directional_derivative!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">directional_derivative!(out,f,q)</code></pre><p>Compute the directional derivative of <code>f</code> in the direction of <code>q</code>, <span>$q\cdot\nabla f$</span>, and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.directional_derivative_conserve!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.directional_derivative_conserve!-Union{Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.directional_derivative_conserve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">directional_derivative_conserve!(out,f,q)</code></pre><p>Compute the conservative form of the directional derivative of <code>f</code> in the direction of <code>q</code>, <span>$\nabla\cdot(qf)$</span>, and put the result into <code>out</code>. Note that the result is not scaled by any grid spacing. This form is only appropriate if <code>q</code> is divergence free.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L98-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}" href="#CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}"><code>CartesianGrids.divergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">divergence!(w::Edges,q::EdgeGradient)</code></pre><p>Evaluate the discrete divergence of edge gradient tensor data <code>q</code> and return it as data <code>w</code>. Note that <code>q</code> can be either primal/dual or dual/primal tensor data, and <code>w</code> must be, respectively, primal or edges type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L222-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}" href="#CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}"><code>CartesianGrids.divergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">divergence!(w::Nodes,q::Edges)</code></pre><p>Evaluate the discrete divergence of edge data <code>q</code> and return it as nodal data <code>w</code>. Note that <code>q</code> can be either primal or dual edge data, but <code>w</code> must be of the same cell type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[3,2] = 1.0;

julia&gt; w = Nodes(Primal,(8,6));

julia&gt; divergence!(w,q)
Nodes{Primal,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
5×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L107-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Union{XEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, YEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, NodePair{Primal, Dual, NX, NY, T, DT} where {T, DT}}} where {NX, NY}" href="#CartesianGrids.divergence!-Union{Tuple{NY}, Tuple{NX}, Tuple{Union{XEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, YEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, NodePair{Primal, Dual, NX, NY, T, DT} where {T, DT}}} where {NX, NY}"><code>CartesianGrids.divergence!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">divergence!(w::XEdges/YEdges,q::NodePair)</code></pre><p>Evaluate the discrete divergence of node pair data <code>q</code> and return it as data <code>w</code>. Note that <code>q</code> can be either primal/dual or dual/primal node data, and <code>w</code> must be, respectively, primal x-edges/dual y-edges or primal y-edges/dual x-edges type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.divergence-Union{Tuple{EdgeGradient{T, S, NX, NY, T1, DT} where {T1&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{S}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, S&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.divergence-Union{Tuple{EdgeGradient{T, S, NX, NY, T1, DT} where {T1&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{S}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, S&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.divergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">divergence(dq::EdgeGradient) --&gt; Edges</code></pre><p>Evaluate the discrete divergence of edge gradient data <code>dq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.divergence-Union{Tuple{Edges{T, NX, NY, T1, DT} where {T1&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.divergence-Union{Tuple{Edges{T, NX, NY, T1, DT} where {T1&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{T}} where {T&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.divergence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">divergence(q::Edges) --&gt; Nodes</code></pre><p>Evaluate the discrete divergence of edge data <code>q</code>. Can also perform this operation by creating an object of Divergence type and applying it with <code>*</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; D = Divergence();

julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[3,2] = 1.0;

julia&gt; D*q
Nodes{Primal,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
5×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L159-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.exp!-Union{Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any, Any}} where {NX, NY}" href="#CartesianGrids.exp!-Union{Tuple{NY}, Tuple{NX}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any}, Tuple{CartesianGrids.Laplacian{NX, NY, T, R, inplace} where {T, R, inplace}, Any, Any}} where {NX, NY}"><code>CartesianGrids.exp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp!(L::Laplacian,a[,Nodes(Dual)])</code></pre><p>Create the in-place version of the integrating factor exp(L*a).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/intfact.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Dual, Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Dual, Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad!(d::EdgeGradient{Dual,Primal},q::Edges{Dual})</code></pre><p>Evaluate the discrete gradient of dual edge data <code>q</code> and return it as edge gradient data <code>d</code>, where the diagonal entries of the gradient lie on dual nodes and the off-diagonal entries lie at primal nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L416-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad!(d::EdgeGradient{Primal,Dual},q::Edges{Primal})</code></pre><p>Evaluate the discrete gradient of primal edge data <code>q</code> and return it as edge gradient data <code>d</code>, where the diagonal entries of the gradient lie on primal nodes and the off-diagonal entries lie at dual nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L391-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad!(q::Edges{Dual},w::Nodes{Dual})</code></pre><p>Evaluate the discrete gradient of dual nodal data <code>w</code> and return it as dual edge data <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L361-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#CartesianGrids.grad!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>CartesianGrids.grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad!(q::Edges{Primal},w::Nodes{Primal})</code></pre><p>Evaluate the discrete gradient of primal nodal data <code>w</code> and return it as primal edge data <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Primal,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; q = Edges(Primal,(8,6));

julia&gt; grad!(q,w)
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L275-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grad-Union{Tuple{Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.grad-Union{Tuple{Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad(q::Edges{Primal/Dual}) --&gt; EdgeGradient{Dual/Primal,Primal/Dual}</code></pre><p>Evaluate the discrete gradient of primal or dual edge data <code>q</code>. Can also perform this operation by creating an object of Grad type and applying it with <code>*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L441-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grad-Union{Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, Tuple{NY}, Tuple{NX}} where {NX, NY}" href="#CartesianGrids.grad-Union{Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, Tuple{NY}, Tuple{NX}} where {NX, NY}"><code>CartesianGrids.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad(w::Nodes{Dual}) --&gt; Edges{Dual}</code></pre><p>Evaluate the discrete gradient of dual nodal data <code>w</code>. Can also perform this operation by creating an object of Grad type and applying it with <code>*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L381-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grad-Union{Tuple{Nodes{Primal, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T)}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}" href="#CartesianGrids.grad-Union{Tuple{Nodes{Primal, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T)}, Tuple{T}, Tuple{NY}, Tuple{NX}} where {NX, NY, T}"><code>CartesianGrids.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grad(w::Nodes{Primal}) --&gt; Edges{Primal}</code></pre><p>Evaluate the discrete gradient of primal nodal data <code>w</code>. Can also perform this operation by creating an object of Grad type and applying it with <code>*</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Primal,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; G = Grad();

julia&gt; G*w
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  -1.0  0.0  0.0  0.0  0.0
 0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/diffcalculus.jl#L323-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grid_interpolate!" href="#CartesianGrids.grid_interpolate!"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grid_interpolate!(out:ScalarGridData,in::ScalarGridData) -&gt; ScalarGridData</code></pre><p>Return the 1-d symmetric interpolation of scalar grid data <code>in</code> onto scalar grid data <code>out</code>. Either <code>in</code> or <code>out</code> must be edge component data and the other must be node data. The direction of interpolation is determined by the relationship of <code>in</code> and <code>out</code>. For example, if <code>in</code> is dual nodes (cell by cell) and <code>out</code> is primal x-edge components (cell by edge), then the interpolation takes place in the y direction, since they are different types in this direction. (In the x direction, they are of the same type (cell), so there is no interpolation in that direction.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/interpolation1d.jl#L7-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{Tuple{Nodes{C, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{C, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, Edges{D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{Tuple{Nodes{C, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{C, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, Edges{D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_interpolate!((wx::Nodes,wy::Nodes),q::Edges)</code></pre><p>Interpolate the edge data <code>q</code> (of either dual or primal type) to the dual or primal nodes, and return the result in <code>wx</code> and <code>wy</code>. <code>wx</code> holds the shifted <code>q.u</code> data and <code>wy</code> the shifted <code>q.v</code> data.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[3,2] = 1.0;

julia&gt; wx = Nodes(Dual,(8,6)); wy = deepcopy(wx);

julia&gt; grid_interpolate!((wx,wy),q);

julia&gt; wx
Nodes{Dual,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0

julia&gt; wy
Nodes{Dual,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/shift.jl#L59-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_interpolate!(dq::EdgeGradient{Primal/Dual},q::Edges{Primal/Dual})</code></pre><p>Interpolate the primal (dual) edge data <code>q</code> to primal (dual) tensor positions and hold it in <code>dq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/shift.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_interpolate!(v::Edges{Dual/Primal},q::Edges{Primal/Dual})</code></pre><p>Interpolate the primal (resp. dual) edge data <code>q</code> to the edges of the dual (resp. primal) cells, and return the result in <code>v</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[3,2] = 1.0;

julia&gt; v = Edges(Dual,(8,6));

julia&gt; grid_interpolate!(v,q)
Edges{Dual,8,6,Float64} data
u (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0   0.0   0.0  0.0  0.0  0.0
 0.0  0.0   0.0   0.0  0.0  0.0  0.0
 0.0  0.0   0.0   0.0  0.0  0.0  0.0
 0.0  0.25  0.25  0.0  0.0  0.0  0.0
 0.0  0.25  0.25  0.0  0.0  0.0  0.0
 0.0  0.0   0.0   0.0  0.0  0.0  0.0
v (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/shift.jl#L232-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_interpolate!(q::Edges{Dual},w::Nodes{Dual})</code></pre><p>Interpolate the dual nodal data <code>w</code> to the edges of the dual cells, and return the result in <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Dual,(8,6));

julia&gt; w[3,4] = 1.0;

julia&gt; q = Edges(Dual,w);

julia&gt; grid_interpolate!(q,w)
Edges{Dual,8,6,Float64} data
u (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.5  0.5  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.5  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/shift.jl#L3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{Primal, Dual, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_interpolate!(q::Edges{Primal/Dual},dq::EdgeGradient{Primal/Dual})</code></pre><p>Interpolate the primal (dual) tensor data <code>dq</code> to primal (dual) edge positions and hold it in <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/shift.jl#L189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#CartesianGrids.grid_interpolate!-Union{Tuple{NY}, Tuple{NX}, Tuple{Edges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT}, Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>CartesianGrids.grid_interpolate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grid_interpolate!(q::Edges{Primal},w::Nodes{Primal})</code></pre><p>Interpolate the primal nodal data <code>w</code> to the edges of the primal cells, and return the result in <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/shift.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.helmholtz!-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T), Nodes{Dual, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T), Number}} where {NX, NY, T&lt;:ComplexF64}" href="#CartesianGrids.helmholtz!-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T), Nodes{Dual, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T), Number}} where {NX, NY, T&lt;:ComplexF64}"><code>CartesianGrids.helmholtz!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">helmholtz!(v,w,α)</code></pre><p>Evaluate the discrete Helmholtz operator (iα - L) on <code>w</code> and return it as <code>v</code>. The data <code>w</code> can be of type dual/primary nodes or edges; <code>v</code> must be of the same type. However, both have to be of complex data type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/helmholtz.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.helmholtz-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Nodes{C, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T), Number}} where {C&lt;:CartesianGrids.CellType, NX, NY, T&lt;:ComplexF64}" href="#CartesianGrids.helmholtz-Union{Tuple{T}, Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Nodes{C, NX, NY, T, DT} where DT&lt;:(AbstractMatrix{T} where T), Number}} where {C&lt;:CartesianGrids.CellType, NX, NY, T&lt;:ComplexF64}"><code>CartesianGrids.helmholtz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">helmholtz(w,α)</code></pre><p>Evaluate the discrete Helmholtz operator (iα - L) on <code>w</code>. The data <code>w</code> can be of complex type dual/primary nodes or edges. The returned result is of the same type as <code>w</code>.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/helmholtz.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.integrate-Tuple{T} where T&lt;:GridData" href="#CartesianGrids.integrate-Tuple{T} where T&lt;:GridData"><code>CartesianGrids.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrate(p::GridData) -&gt; Real</code></pre><p>Computes a numerical quadrature of node data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.interpolatable_field-Tuple{AbstractArray, AbstractArray, ScalarGridData}" href="#CartesianGrids.interpolatable_field-Tuple{AbstractArray, AbstractArray, ScalarGridData}"><code>CartesianGrids.interpolatable_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolatable_field(x,y,f::ScalarGridData)</code></pre><p>Generates an interpolatable version of grid data <code>f</code>, based on coordinates in <code>x</code> and <code>y</code> (which should be in range form). The output can be called as a function with coordinate pairs as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/interpolation.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.interpolatable_field-Tuple{AbstractRange, AbstractRange, AbstractRange, AbstractRange, Union{Edges, NodePair}}" href="#CartesianGrids.interpolatable_field-Tuple{AbstractRange, AbstractRange, AbstractRange, AbstractRange, Union{Edges, NodePair}}"><code>CartesianGrids.interpolatable_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolatable_field(xu,yu,xv,yv,f::EdgeData/NodePair)</code></pre><p>Generates an interpolatable version of grid data <code>f</code>, based on coordinates in <code>xu</code>, <code>yu</code>, <code>xv</code>, <code>yv</code> (which should be in range form). The output can be called as a function with coordinate pairs as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/interpolation.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.interpolatable_field-Tuple{GridData, PhysicalGrid}" href="#CartesianGrids.interpolatable_field-Tuple{GridData, PhysicalGrid}"><code>CartesianGrids.interpolatable_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interpolatable_field(f::GridData,g::PhysicalGrid)</code></pre><p>Generates an interpolatable version of grid data <code>f</code>, based on grid <code>g</code>. The output can be called as a function with coordinate pairs as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/interpolation.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.laplacian!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#CartesianGrids.laplacian!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>CartesianGrids.laplacian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laplacian!(v,w)</code></pre><p>Evaluate the discrete Laplacian of <code>w</code> and return it as <code>v</code>. The data <code>w</code> can be of type dual/primary nodes or edge components or edges; <code>v</code> must be of the same type.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Dual,(8,6));

julia&gt; v = deepcopy(w);

julia&gt; w[4,3] = 1.0;

julia&gt; laplacian!(v,w)
Nodes{Dual,8,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×8 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  -4.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0   1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/laplacian.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.laplacian-Union{Tuple{Nodes{C, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.laplacian-Union{Tuple{Nodes{C, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}, Tuple{NY}, Tuple{NX}, Tuple{C}} where {C&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.laplacian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laplacian(w)</code></pre><p>Evaluate the discrete Laplacian of <code>w</code>. The data <code>w</code> can be of type dual/primary nodes or edges. The returned result is of the same type as <code>w</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Edges(Primal,(8,6));

julia&gt; q.u[2,2] = 1.0;

julia&gt; laplacian(q)
Edges{Primal,8,6,Float64} data
u (in grid orientation)
5×8 Array{Float64,2}:
 0.0   0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0   1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  -4.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0   0.0  0.0  0.0  0.0  0.0  0.0  0.0
v (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/laplacian.jl#L131-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.laplacian_symm!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#CartesianGrids.laplacian_symm!-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>CartesianGrids.laplacian_symm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laplacian_symm!(v,w)</code></pre><p>Evaluate the symmetric 5-point discrete Laplacian of <code>w</code> and return it as <code>v</code>. The data <code>w</code> can be of type dual nodes only for now. This symmetric Laplacian also evaluates the partial Laplacians (using only available stencil data) on the ghost nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/laplacian.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.limits-Tuple{PhysicalGrid, Int64}" href="#CartesianGrids.limits-Tuple{PhysicalGrid, Int64}"><code>CartesianGrids.limits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">limits(g::PhysicalGrid,d::Int) -&gt; Tuple</code></pre><p>Return the minimum and maximum physical dimensions in direction <code>d</code> for grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.mag!-Union{Tuple{C}, Tuple{Nodes{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.mag!-Union{Tuple{C}, Tuple{Nodes{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.mag!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mag!(magu::Nodes{Primal/Dual},u::Edges{Primal/Dual})</code></pre><p>Calculate the in-placed magnitude of vector grid data <code>u</code>, placing the result on the cell centers in <code>magu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.mag-Union{Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}, Tuple{C}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.mag-Union{Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}, Tuple{C}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.mag</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mag(u::Edges{Primal/Dual}) -&gt; Nodes{Primal/Dual}</p><p>Calculate the magnitude of vector grid data <code>u</code>, placing the result on the cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.magsq!-Union{Tuple{C}, Tuple{Nodes{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.magsq!-Union{Tuple{C}, Tuple{Nodes{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.magsq!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>magsq!(magusq::Nodes{Primal/Dual},u::Edges{Primal/Dual})</p><p>Calculate the in-placed squared magnitude of vector grid data <code>u</code>, placing the result on the cell centers in <code>magusq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.magsq-Union{Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}, Tuple{C}} where C&lt;:CartesianGrids.CellType" href="#CartesianGrids.magsq-Union{Tuple{Edges{C, NX, NY, T, DT} where {NX, NY, T&lt;:Number, DT}}, Tuple{C}} where C&lt;:CartesianGrids.CellType"><code>CartesianGrids.magsq</code></a> — <span class="docstring-category">Method</span></header><section><div><p>magsq(u::Edges{Primal/Dual}) -&gt; Nodes{Primal/Dual}</p><p>Calculate the squared magnitude of vector grid data <code>u</code>, placing the result on the cell centers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/nlcalculus.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.origin-Tuple{PhysicalGrid}" href="#CartesianGrids.origin-Tuple{PhysicalGrid}"><code>CartesianGrids.origin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">origin(g::PhysicalGrid) -&gt; Tuple{Int,Int}</code></pre><p>Return a tuple of the indices of the primal node that corresponds to the physical origin of the coordinate system used by <code>g</code>. Note that these indices need not lie inside the range of indices occupied by the grid. For example, if the range of physical coordinates occupied by the grid is (1.0,3.0) x (2.0,4.0), then the origin is not inside the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.plan_helmholtz" href="#CartesianGrids.plan_helmholtz"><code>CartesianGrids.plan_helmholtz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_helmholtz(dims::Tuple,α::Number,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [dx=1.0])</code></pre><p>Constructor to set up an operator for evaluating the discrete Helmholtz operator on complex dual or primal nodal data of dimension <code>dims</code>. If the optional keyword <code>with_inverse</code> is set to <code>true</code>, then it also sets up the inverse Helmholtz operator (the lattice Green&#39;s function, LGF). These can then be applied, respectively, with <code>*</code> and <code>\</code> operations on data of the appropriate size. The optional parameter <code>dx</code> is used in adjusting the uniform value of the LGF to match the behavior of the continuous analog at large distances; this is set to 1.0 by default.</p><p>Instead of the first argument, one can also supply <code>w::Nodes</code> to specify the size of the domain.</p><p><strong>Example</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/helmholtz.jl#L60-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.plan_helmholtz!" href="#CartesianGrids.plan_helmholtz!"><code>CartesianGrids.plan_helmholtz!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_helmholtz!(dims::Tuple,α::Number,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [dx=1.0])</code></pre><p>Same as <a href="#CartesianGrids.plan_helmholtz"><code>plan_helmholtz</code></a>, but forms an operator that works in-place on the data it operates on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/helmholtz.jl#L80-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.plan_intfact" href="#CartesianGrids.plan_intfact"><code>CartesianGrids.plan_intfact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_intfact(a::Real,dims::Tuple,[fftw_flags=FFTW.ESTIMATE])</code></pre><p>Constructor to set up an operator for evaluating the integrating factor with real-valued parameter <code>a</code>. This can then be applied with the <code>*</code> or `` operation on data of the appropriate size.</p><p>Note that <code>a</code> can be positive, negative, or zero. However, if <code>a</code> is negative, then only the <span>$operation is actually correct; the `*` operation merely returns the identity to avoid excessive (and noisy) calculation. Similarly, if `a` is positive, the$</span> operation returns the identity. Thus, these operations are not inverses of one another. If <code>a</code> is zero, both operations return the identity.</p><p>The <code>dims</code> argument can be replaced with data of type <code>ScalarGridData</code> to specify the size of the domain.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Dual,(6,6));

julia&gt; w[4,4] = 1.0;

julia&gt; E = plan_intfact(1.0,(6,6))
Integrating factor with parameter 1.0 on a (nx = 6, ny = 6) grid

julia&gt; E*w
Nodes{Dual,6,6,Float64} data
Printing in grid orientation (lower left is (1,1))
6×6 Array{Float64,2}:
 0.00268447   0.00869352  0.0200715   0.028765    0.0200715   0.00869352
 0.00619787   0.0200715   0.0463409   0.0664124   0.0463409   0.0200715
 0.00888233   0.028765    0.0664124   0.0951774   0.0664124   0.028765
 0.00619787   0.0200715   0.0463409   0.0664124   0.0463409   0.0200715
 0.00268447   0.00869352  0.0200715   0.028765    0.0200715   0.00869352
 0.000828935  0.00268447  0.00619787  0.00888233  0.00619787  0.00268447</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/intfact.jl#L13-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.plan_intfact!" href="#CartesianGrids.plan_intfact!"><code>CartesianGrids.plan_intfact!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_intfact!(a::Real,dims::Tuple,[fftw_flags=FFTW.ESTIMATE])</code></pre><p>Same as <a href="#CartesianGrids.plan_intfact"><code>plan_intfact</code></a>, but the resulting operator performs an in-place operation on data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/intfact.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.plan_laplacian" href="#CartesianGrids.plan_laplacian"><code>CartesianGrids.plan_laplacian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_laplacian(dims::Tuple,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [factor=1.0],[dx=1.0],[dtype=Float64])</code></pre><p>Constructor to set up an operator for evaluating the discrete Laplacian on dual or primal nodal data of dimension <code>dims</code>. If the optional keyword <code>with_inverse</code> is set to <code>true</code>, then it also sets up the inverse Laplacian (the lattice Green&#39;s function, LGF). These can then be applied, respectively, with <code>*</code> and <code>\</code> operations on data of the appropriate size. The optional parameter <code>factor</code> is a scalar used to multiply the result of the operator and divide the inverse. The optional parameter <code>dx</code> is used in adjusting the uniform value of the LGF to match the behavior of the continuous analog at large distances; this is set to 1.0 by default. The type of data on which to act is floating point by default, but can also be ComplexF64. This is specified with the optional parameter <code>dtype</code></p><p>Instead of the first argument, one can also supply <code>w::Nodes</code> to specify the size of the domain.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; w = Nodes(Dual,(5,5));

julia&gt; w[3,3] = 1.0;

julia&gt; L = plan_laplacian(5,5;with_inverse=true)
Discrete Laplacian (and inverse) on a (nx = 5, ny = 5) grid acting on Float64 data with spacing 1.0

julia&gt; s = L\w
Nodes{Dual,5,5,Float64} data
Printing in grid orientation (lower left is (1,1))
5×5 Array{Float64,2}:
 0.16707    0.129276     0.106037     0.129276    0.16707
 0.129276   0.0609665   -0.00734343   0.0609665   0.129276
 0.106037  -0.00734343  -0.257343    -0.00734343  0.106037
 0.129276   0.0609665   -0.00734343   0.0609665   0.129276
 0.16707    0.129276     0.106037     0.129276    0.16707

julia&gt; L*s ≈ w
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/laplacian.jl#L210-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.plan_laplacian!" href="#CartesianGrids.plan_laplacian!"><code>CartesianGrids.plan_laplacian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_laplacian!(dims::Tuple,[with_inverse=false],[fftw_flags=FFTW.ESTIMATE],
                      [factor=1.0])</code></pre><p>Same as <a href="#CartesianGrids.plan_laplacian"><code>plan_laplacian</code></a>, but operates in-place on data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/laplacian.jl#L255-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{ScalarData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>CartesianGrids.pointwise_dot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointwise_dot!(C::ScalarData,A::VectorData,B::VectorData) -&gt; ScalarData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code> and return the result in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#CartesianGrids.pointwise_dot!-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>CartesianGrids.pointwise_dot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointwise_dot!(C::VectorData,A::TensorData/VectorData,B::VectorData/TensorData) -&gt; VectorData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code>, where one is <code>TensorData</code> and the other is <code>VectorData</code> and return the result as <code>VectorData</code> in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L328-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>CartesianGrids.pointwise_dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointwise_dot(A::TensorData/VectorData,B::VectorData/TensorData) -&gt; VectorData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code>, where one is <code>TensorData</code> and the other is <code>VectorData</code> and return the result as <code>VectorData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L341-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#CartesianGrids.pointwise_dot-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>CartesianGrids.pointwise_dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointwise_dot(A::VectorData,B::VectorData) -&gt; ScalarData</code></pre><p>Compute the element by element dot product between <code>A</code> and <code>B</code> and return the result as <code>ScalarData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L318-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.product" href="#CartesianGrids.product"><code>CartesianGrids.product</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">product(p::PointData,q::PointData) -&gt; PointData
(∘)(p::PointData,q::PointData) -&gt; PointData</code></pre><p>Compute the Hadamard (i.e. element by element) product of point data data <code>p</code> and <code>q</code>. Works similarly to <code>product!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L193-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.product!-Union{Tuple{N}, Tuple{PointData{N, T} where T, PointData{N, T} where T, PointData{N, T} where T}} where N" href="#CartesianGrids.product!-Union{Tuple{N}, Tuple{PointData{N, T} where T, PointData{N, T} where T, PointData{N, T} where T}} where N"><code>CartesianGrids.product!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product!(out::PointData,p::PointData,q::PointData)</code></pre><p>Compute the Hadamard (i.e. element by element) product of point data data <code>p</code> and <code>q</code> and return the result in <code>out</code>. Note that <code>p</code> and <code>q</code> can be of mixed type (scalar, vector, tensor), as long as one of them is a scalar. Also, <code>out</code> must have element type that is consistent with the promoted type of <code>p</code> and <code>q</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; fcs = ScalarData(5,dtype=ComplexF64);

julia&gt; fill!(fcs,2im)
5 points of scalar-valued Complex{Float64} data
5-element Array{Complex{Float64},1}:
 0.0 + 2.0im
 0.0 + 2.0im
 0.0 + 2.0im
 0.0 + 2.0im
 0.0 + 2.0im

julia&gt; frt = TensorData(fcs,dtype=Float64);

julia&gt; fill!(frt,1.0)
5 points of tensor-valued Float64 data dudx, dudy, dvdx, dvdy
5×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; out = similar(frt,element_type=ComplexF64);

julia&gt; product!(out,frt,fcs)
5 points of tensor-valued Complex{Float64} data dudx, dudy, dvdx, dvdy
5×4 Array{Complex{Float64},2}:
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im
 0.0+2.0im  0.0+2.0im  0.0+2.0im  0.0+2.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L82-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.product!-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:GridData" href="#CartesianGrids.product!-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:GridData"><code>CartesianGrids.product!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product!(out::GridData,p::GridData,q::GridData)</code></pre><p>Compute the Hadamard (i.e. element by element) product of grid data <code>p</code> and <code>q</code> (of the same type) and return the result in <code>out</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Edges(Dual,(8,6));

julia&gt; out = p = deepcopy(q);

julia&gt; q.u[3,2] = 0.3;

julia&gt; p.u[3,2] = 0.2;

julia&gt; product!(out,p,q)
Edges{Dual,8,6,Float64} data
u (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.06  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
v (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/basicoperations.jl#L38-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.product-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GridData" href="#CartesianGrids.product-Union{Tuple{T}, Tuple{T, T}} where T&lt;:GridData"><code>CartesianGrids.product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">product(p::Edges/Nodes,q::Edges/Nodes) --&gt; Edges/Nodes</code></pre><p>Compute the Hadamard product of edge or nodal (primal or dual) data <code>p</code> and <code>q</code> and return the result. This operation can also be carried out with the <code>∘</code> operator:</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; q = Edges(Dual,(8,6));

julia&gt; p = deepcopy(q);

julia&gt; q.u[3,2] = 0.3;

julia&gt; p.u[3,2] = 0.2;

julia&gt; p∘q
Edges{Dual,8,6,Float64} data
u (in grid orientation)
6×7 Array{Float64,2}:
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
 0.0  0.0  0.06  0.0  0.0  0.0  0.0
 0.0  0.0  0.0   0.0  0.0  0.0  0.0
v (in grid orientation)
5×8 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/basicoperations.jl#L83-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.tensorproduct!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#CartesianGrids.tensorproduct!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>CartesianGrids.tensorproduct!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensorproduct!(q::EdgeGradient,u::Edges,v::Edges,ut::EdgeGradient,vt::EdgeGradient)</code></pre><p>In-place tensor product of <code>u</code> and <code>v</code>, with the result returned in <code>q</code>. The <code>ut</code> and <code>vt</code> are supplied as temporary storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/basicoperations.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.tensorproduct!-Union{Tuple{N}, Tuple{TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#CartesianGrids.tensorproduct!-Union{Tuple{N}, Tuple{TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>CartesianGrids.tensorproduct!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensorproduct!(pq::TensorData,p::VectorData,q::VectorData) -&gt; TensorData</code></pre><p>Calculate the element by element tensor product between vectors <code>p</code> and <code>q</code>, returning data in <code>pq</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CartesianGrids.volume-Union{Tuple{PhysicalGrid{ND}}, Tuple{ND}} where ND" href="#CartesianGrids.volume-Union{Tuple{PhysicalGrid{ND}}, Tuple{ND}} where ND"><code>CartesianGrids.volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">volume(g::PhysicalGrid) -&gt; Float64</code></pre><p>Return the volume (or area) of the physical grid <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/physical/physicalgrid.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.cross-Tuple{Union{Number, ScalarData}, VectorData}" href="#LinearAlgebra.cross-Tuple{Union{Number, ScalarData}, VectorData}"><code>LinearAlgebra.cross</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cross(a::Number/ScalarData,A::VectorData) -&gt; VectorData
×(a::Number/ScalarData,A::VectorData) -&gt; VectorData</code></pre><p>Compute the cross product between the scalar <code>a</code> (treated as an out-of-plane component of a vector) and the planar vector data <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L270-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.cross-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#LinearAlgebra.cross-Union{Tuple{N}, Tuple{VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, VectorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>LinearAlgebra.cross</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cross(A::VectorData,B::VectorData) -&gt; ScalarData
×(A::VectorData,A::VectorData) -&gt; ScalarData</code></pre><p>Compute the cross product between the vector point data <code>A</code> and <code>B</code> and return the result as scalar data (treated as an out-of-plane component of a vector).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L296-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{C}, Tuple{Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}, Edges{C, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::Edges{Dual/Primal},p2::Edges{Dual/Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of edge data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::EdgeGradient{Dual/Primal},p2::EdgeGradient{Dual/Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of edge gradient data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::Nodes{Dual},p2::Nodes{Dual}) -&gt; Real</code></pre><p>Computes the inner product between two sets of dual node data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, Nodes{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::Nodes{Primal},p2::Nodes{Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of primal node data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, XEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, XEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::XEdges{Dual},p2::XEdges{Dual}) -&gt; Real</code></pre><p>Computes the inner product between two sets of dual x-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, XEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{XEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, XEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::XEdges{Primal},p2::XEdges{Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of primal x-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, YEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, YEdges{Dual, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::YEdges{Dual},p2::YEdges{Dual}) -&gt; Real</code></pre><p>Computes the inner product between two sets of dual y-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, YEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}" href="#LinearAlgebra.dot-Union{Tuple{NY}, Tuple{NX}, Tuple{YEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}, YEdges{Primal, NX, NY, T, DT} where {T&lt;:Number, DT&lt;:(AbstractMatrix{T} where T)}}} where {NX, NY}"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(p1::YEdges{Primal},p2::YEdges{Primal}) -&gt; Real</code></pre><p>Computes the inner product between two sets of primal y-edge component data on the same grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, TensorData}} where T&lt;:Number" href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, TensorData}} where T&lt;:Number"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(A::Tuple{T,T},B::TensorData) where {T&lt;:Number} -&gt; VectorData
⋅(A::Tuple{T,T},B::TensorData) where {T&lt;:Number} -&gt; VectorData</code></pre><p>Computes the dot product between the tuple <code>A</code> and the elements of a tensor <code>B</code> on a set of points and returns vector data on the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L417-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, VectorData}} where T&lt;:Number" href="#LinearAlgebra.dot-Union{Tuple{T}, Tuple{Tuple{T, T}, VectorData}} where T&lt;:Number"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dot(A::Tuple{T,T},B::VectorData) where {T&lt;:Number} -&gt; ScalarData
⋅(A::Tuple{T,T},B::VectorData) where {T&lt;:Number} -&gt; ScalarData</code></pre><p>Computes the dot product between the tuple <code>v</code> and the elements of a tensor <code>B</code> on a set of points and returns scalar data on the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L403-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{GridData}" href="#LinearAlgebra.norm-Tuple{GridData}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(p::GridData) -&gt; Real</code></pre><p>Computes the L2 norm of data on a grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/innerproducts.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.transpose!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}" href="#LinearAlgebra.transpose!-Union{Tuple{NY}, Tuple{NX}, Tuple{D}, Tuple{C}, Tuple{EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}, EdgeGradient{C, D, NX, NY, T, DT} where {T&lt;:Number, DT}}} where {C&lt;:CartesianGrids.CellType, D&lt;:CartesianGrids.CellType, NX, NY}"><code>LinearAlgebra.transpose!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transpose!(pt::EdgeGradient,p::EdgeGradient)</code></pre><p>In-place element-by-element transpose of <code>EdgeGradient</code> <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/gridoperations/basicoperations.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.transpose!-Union{Tuple{N}, Tuple{TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N" href="#LinearAlgebra.transpose!-Union{Tuple{N}, Tuple{TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}, TensorData{N, T, DT} where {T, DT&lt;:(AbstractVector{T} where T)}}} where N"><code>LinearAlgebra.transpose!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transpose!(pt::TensorData,p::TensorData)</code></pre><p>In-place element-by-element transpose of <code>TensorData</code> <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIBPM/CartesianGrids.jl/blob/94e3b40a1b932e19ac778fd4446b5b7bdfba7ec2/src/points/basicpointoperations.jl#L249-L253">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../immersed/">« Immersed data and their operations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 28 April 2021 16:48">Wednesday 28 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
